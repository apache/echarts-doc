{
  "title": "<p>标题组件，包含主标题和副标题。</p>\n<p>在 ECharts 2.x 中单个 ECharts 实例最多只能拥有一个标题组件。但是在 ECharts 3 中可以存在任意多个标题组件，这在需要标题进行排版，或者单个实例中的多个图表都需要标题时会比较有用。</p>\n<p><strong>例如下面不同缓动函数效果的示例，每一个缓动效果图都带有一个标题组件：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-easing&edit=1&reset=1\" width=\"700\" height=\"400\" ></iframe>\n\n\n\n",
  "legend": "<p>图例组件。</p>\n<p>图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。</p>\n<p>ECharts 3 中单个 echarts 实例中可以存在多个图例组件，会方便多个图例的布局。</p>\n<p>当图例数量过多时，可以使用 <a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=pie-legend&amp;edit=1&amp;reset=1\" target=\"_blank\">滚动图例（垂直）</a> 或 <a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=radar2&amp;edit=1&amp;reset=1\" target=\"_blank\">滚动图例（水平）</a>，参见：<a href=\"#legend.type\">legend.type</a></p>\n",
  "grid": "<p>直角坐标系内绘图网格，单个 grid 内最多可以放置上下两个 X 轴，左右两个 Y 轴。可以在网格上绘制<a href=\"#series-line\">折线图</a>，<a href=\"#series-bar\">柱状图</a>，<a href=\"#series-scatter\">散点图（气泡图）</a>。</p>\n<p>在 ECharts 2.x 里单个 echarts 实例中最多只能存在一个 grid 组件，在 ECharts 3 中可以存在任意个 grid 组件。</p>\n<p><strong>例如下面这个 Anscombe Quartet 的示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=scatter-anscombe-quartet&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n",
  "xAxis": "<p>直角坐标系 grid 中的 x 轴，一般情况下单个 grid 组件最多只能放上下两个 x 轴，多于两个 x 轴需要通过配置 <a href=\"#xAxis.offset\">offset</a> 属性防止同个位置多个 x 轴的重叠。</p>\n",
  "yAxis": "<p>直角坐标系 grid 中的 y 轴，一般情况下单个 grid 组件最多只能放左右两个 y 轴，多于两个 y 轴需要通过配置 <a href=\"#yAxis.offset\">offset</a> 属性防止同个位置多个 Y 轴的重叠。</p>\n",
  "polar": "<p>极坐标系，可以用于散点图和折线图。每个极坐标系拥有一个<a href=\"#angleAxis\">角度轴</a>和一个<a href=\"#radiusAxis\">半径轴</a>。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=scatter-polar-punchCard&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n",
  "radiusAxis": "<p>极坐标系的径向轴。</p>\n",
  "angleAxis": "<p>极坐标系的角度轴。</p>\n",
  "radar": "<p>雷达图坐标系组件，只适用于<a href=\"#series-radar\">雷达图</a>。该组件等同 ECharts 2 中的 polar 组件。因为 3 中的 polar 被重构为标准的极坐标组件，为避免混淆，雷达图使用 radar 组件作为其坐标系。</p>\n<p>雷达图坐标系与极坐标系不同的是它的每一个轴（indicator 指示器）都是一个单独的维度，可以通过 <a href=\"#radar.name\">name</a>、<a href=\"#radar.axisLine\">axisLine</a>、<a href=\"#radar.axisTick\">axisTick</a>、<a href=\"#radar.axisLabel\">axisLabel</a>、<a href=\"#radar.splitLine\">splitLine</a>、 <a href=\"#radar.splitArea\">splitArea</a> 几个配置项配置指示器坐标轴线的样式。</p>\n<p>下面是一个 radar 组件的一个自定义例子。</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/radar&edit=1&reset=1\" width=\"400\" height=\"400\" ></iframe>\n\n\n\n",
  "dataZoom": "<p><code class=\"codespan\">dataZoom</code> 组件 用于区域缩放，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响。</p>\n<p>现在支持这几种类型的 <code class=\"codespan\">dataZoom</code> 组件：</p>\n<ul>\n<li><p><a href=\"#dataZoom-inside\">内置型数据区域缩放组件（dataZoomInside）</a>：内置于坐标系中，使用户可以在坐标系上通过鼠标拖拽、鼠标滚轮、手指滑动（触屏上）来缩放或漫游坐标系。</p>\n</li>\n<li><p><a href=\"#dataZoom-slider\">滑动条型数据区域缩放组件（dataZoomSlider）</a>：有单独的滑动条，用户在滑动条上进行缩放或漫游。</p>\n</li>\n<li><p><a href=\"#toolbox.feature.dataZoom\">框选型数据区域缩放组件（dataZoomSelect）</a>：提供一个选框进行数据区域缩放。即 <a href=\"#toolbox.feature.dataZoom\">toolbox.feature.dataZoom</a>，配置项在 <code class=\"codespan\">toolbox</code> 中。</p>\n</li>\n</ul>\n<p>如下例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/scatter-dataZoom-all&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><br></p>\n<hr>\n<p><strong>✦ dataZoom 和 数轴的关系 ✦</strong></p>\n<p><code class=\"codespan\">dataZoom</code> 主要是对 <code class=\"codespan\">数轴（axis）</code> 进行操作（控制数轴的显示范围，或称窗口（window））。</p>\n<blockquote>\n<p>可以通过 <a href=\"#dataZoom.xAxisIndex\">dataZoom.xAxisIndex</a> 或 <a href=\"#dataZoom.yAxisIndex\">dataZoom.yAxisIndex</a> 或 <a href=\"#dataZoom.radiusAxisIndex\">dataZoom.radiusAxisIndex</a> 或 <a href=\"#dataZoom.angleAxisIndex\">dataZoom.angleAxisIndex</a> 来指定 <code class=\"codespan\">dataZoom</code> 控制哪个或哪些数轴。</p>\n</blockquote>\n<p><code class=\"codespan\">dataZoom</code> 组件可 <strong>同时存在多个</strong>，起到共同控制的作用。如果多个 <code class=\"codespan\">dataZoom</code> 组件共同控制同一个数轴，他们会自动联动。</p>\n<p><br></p>\n<hr>\n<p><strong>✦ dataZoom 组件如何影响轴和数据 ✦</strong></p>\n<p><code class=\"codespan\">dataZoom</code> 的运行原理是通过 <code class=\"codespan\">数据过滤</code> 以及在内部设置轴的显示窗口来达到 <code class=\"codespan\">数据窗口缩放</code> 的效果。</p>\n<p>数据过滤模式（<a href=\"#dataZoom.filterMode\">dataZoom.filterMode</a>）的设置不同，效果也不同。</p>\n<p>可选值为：</p>\n<ul>\n<li><p>&#39;filter&#39;：当前数据窗口外的数据，被 <strong>过滤掉</strong>。即 <strong>会</strong> 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。</p>\n</li>\n<li><p>&#39;weakFilter&#39;：当前数据窗口外的数据，被 <strong>过滤掉</strong>。即 <strong>会</strong> 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。</p>\n</li>\n<li><p>&#39;empty&#39;：当前数据窗口外的数据，被 <strong>设置为空</strong>。即 <strong>不会</strong> 影响其他轴的数据范围。</p>\n</li>\n<li><p>&#39;none&#39;: 不过滤数据，只改变数轴范围。</p>\n</li>\n</ul>\n<p>如何设置，由用户根据场景和需求自己决定。经验来说：</p>\n<ul>\n<li><p>当『只有 X 轴 或 只有 Y 轴受 <code class=\"codespan\">dataZoom</code> 组件控制』时，常使用 <code class=\"codespan\">filterMode: &#39;filter&#39;</code>，这样能使另一个轴自适应过滤后的数值范围。</p>\n</li>\n<li><p>当『X 轴 Y 轴分别受 <code class=\"codespan\">dataZoom</code> 组件控制』时：</p>\n<ul>\n<li><p>如果 X 轴和 Y 轴是『同等地位的、不应互相影响的』，比如在『双数值轴散点图』中，那么两个轴可都设为 <code class=\"codespan\">fiterMode: &#39;empty&#39;</code>。</p>\n</li>\n<li><p>如果 X 轴为主，Y 轴为辅，比如在『柱状图』中，需要『拖动 <code class=\"codespan\">dataZoomX</code> 改变 X 轴过滤柱子时，Y 轴的范围也自适应剩余柱子的高度』，『拖动 <code class=\"codespan\">dataZoomY</code> 改变 Y 轴过滤柱子时，X 轴范围不受影响』，那么就 X轴设为 <code class=\"codespan\">fiterMode: &#39;filter&#39;</code>，Y 轴设为 <code class=\"codespan\">fiterMode: &#39;empty&#39;</code>，即主轴 <code class=\"codespan\">&#39;filter&#39;</code>，辅轴 <code class=\"codespan\">&#39;empty&#39;</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>下面是个具体例子：</p>\n<pre><code class=\"lang-javascript\">option = {\n    dataZoom: [\n        {\n            id: &#39;dataZoomX&#39;,\n            type: &#39;slider&#39;,\n            xAxisIndex: [0],\n            filterMode: &#39;filter&#39;\n        },\n        {\n            id: &#39;dataZoomY&#39;,\n            type: &#39;slider&#39;,\n            yAxisIndex: [0],\n            filterMode: &#39;empty&#39;\n        }\n    ],\n    xAxis: {type: &#39;value&#39;},\n    yAxis: {type: &#39;value&#39;},\n    series{\n        type: &#39;bar&#39;,\n        data: [\n            // 第一列对应 X 轴，第二列对应 Y 轴。\n            [12, 24, 36],\n            [90, 80, 70],\n            [3, 9, 27],\n            [1, 11, 111]\n        ]\n    }\n}\n</code></pre>\n<p>上例中，<code class=\"codespan\">dataZoomX</code> 的 <code class=\"codespan\">filterMode</code> 设置为 <code class=\"codespan\">&#39;filter&#39;</code>。于是，假设当用户拖拽 <code class=\"codespan\">dataZoomX</code>（不去动 <code class=\"codespan\">dataZoomY</code>）导致其 valueWindow 变为 <code class=\"codespan\">[2, 50]</code> 时，<code class=\"codespan\">dataZoomX</code> 对 series.data 的第一列进行遍历，窗口外的整项去掉，最终得到的 series.data 为：</p>\n<pre><code class=\"lang-javascript\">[\n    // 第一列对应 X 轴，第二列对应 Y 轴。\n    [12, 24, 36],\n    // [90, 80, 70] 整项被过滤掉，因为 90 在 dataWindow 之外。\n    [3, 9, 27]\n    // [1, 11, 111] 整项被过滤掉，因为 1 在 dataWindow 之外。\n]\n</code></pre>\n<p>过滤前，series.data 中对应 Y 轴的值有 <code class=\"codespan\">24</code>、<code class=\"codespan\">80</code>、<code class=\"codespan\">9</code>、<code class=\"codespan\">11</code>，过滤后，只剩下 <code class=\"codespan\">24</code> 和 <code class=\"codespan\">9</code>，那么 Y 轴的显示范围就会自动改变以适应剩下的这两个值的显示（如果 Y 轴没有被设置 <code class=\"codespan\">min</code>、<code class=\"codespan\">max</code> 固定其显示范围的话）。</p>\n<p>所以，<code class=\"codespan\">filterMode: &#39;filter&#39;</code> 的效果是：过滤数据后使另外的轴也能自动适应当前数据的范围。</p>\n<p>再从头来，上例中 <code class=\"codespan\">dataZoomY</code> 的 <code class=\"codespan\">filterMode</code> 设置为 <code class=\"codespan\">&#39;empty&#39;</code>。于是，假设当用户拖拽 <code class=\"codespan\">dataZoomY</code>（不去动 <code class=\"codespan\">dataZoomX</code>）导致其 dataWindow 变为 <code class=\"codespan\">[10, 60]</code> 时，<code class=\"codespan\">dataZoomY</code> 对 series.data 的第二列进行遍历，窗口外的值被设置为 empty （即替换为 NaN，这样设置为空的项，其所对应柱形，在 X 轴还有占位，只是不显示出来）。最终得到的 series.data 为：</p>\n<pre><code class=\"lang-javascript\">[\n    // 第一列对应 X 轴，第二列对应 Y 轴。\n    [12, 24, 36],\n    [90, NaN, 70], // 设置为 empty (NaN)\n    [3, NaN, 27],  // 设置为 empty (NaN)\n    [1, 11, 111]\n]\n</code></pre>\n<p>这时，series.data 中对应于 X 轴的值仍然全部保留不受影响，为 <code class=\"codespan\">12</code>、<code class=\"codespan\">90</code>、<code class=\"codespan\">3</code>、<code class=\"codespan\">1</code>。那么用户对 <code class=\"codespan\">dataZoomY</code> 的拖拽操作不会影响到 X 轴的范围。这样的效果，对于离群点（outlier）过滤功能，比较清晰。</p>\n<p>如下面的例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/bar-dataZoom-filterMode&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n\n\n<p>另外，如果在任一个数轴上设置了 <code class=\"codespan\">min</code>、<code class=\"codespan\">max</code>（如设置 <code class=\"codespan\">yAxis: {min: 0, max: 400}</code>），那么这个数轴无论如何也不会被其他数轴的 dataZoom 行为影响了。</p>\n<p><br></p>\n<hr>\n<p><strong>✦ 数据窗口的设置 ✦</strong></p>\n<p><code class=\"codespan\">dataZoom</code> 的数据窗口范围的设置，目前支持两种形式：</p>\n<ul>\n<li><p>百分比形式：即设置 <a href=\"#dataZoom.start\">dataZoom.start</a> 和 <a href=\"#dataZoom.end\">dataZoom.end</a>。</p>\n</li>\n<li><p>绝对数值形式：即设置 <a href=\"#dataZoom.startValue\">dataZoom.startValue</a> 和 <a href=\"#dataZoom.endValue\">dataZoom.endValue</a>。</p>\n</li>\n</ul>\n<p>注意：当使用百分比形式指定 <code class=\"codespan\">dataZoom</code> 范围时，且处于如下场景（或类似场景）中，<code class=\"codespan\">dataZoom</code> 的结果是和 <code class=\"codespan\">dataZoom</code> 组件的定义顺序相关的。</p>\n<pre><code class=\"lang-javascript\">option = {\n    dataZoom: [\n        {\n            id: &#39;dataZoomX&#39;,\n            type: &#39;slider&#39;,\n            xAxisIndex: [0],\n            filterMode: &#39;filter&#39;, // 设定为 &#39;filter&#39; 从而 X 的窗口变化会影响 Y 的范围。\n            start: 30,\n            end: 70\n        },\n        {\n            id: &#39;dataZoomY&#39;,\n            type: &#39;slider&#39;,\n            yAxisIndex: [0],\n            filterMode: &#39;empty&#39;,\n            start: 20,\n            end: 80\n        }\n    ],\n    xAxis: {\n        type: &#39;value&#39;\n    },\n    yAxis: {\n        type: &#39;value&#39;\n        // yAxis 中并没有使用 min、max 来显示限定轴的显示范围。\n    },\n    series{\n        type: &#39;bar&#39;,\n        data: [\n            // 第一列对应 X 轴，第二列对应 Y 轴。\n            [12, 24, 36],\n            [90, 80, 70],\n            [3, 9, 27],\n            [1, 11, 111]\n        ]\n    }\n}\n</code></pre>\n<p>在上例中，<code class=\"codespan\">dataZoomY</code> 的 <code class=\"codespan\">start: 20, end: 80</code> 到底表示什么意思？</p>\n<ul>\n<li><p>如果 <code class=\"codespan\">yAxis.min</code>、<code class=\"codespan\">yAxis.max</code> 进行了直接设置：</p>\n<p>  那么 <code class=\"codespan\">dataZoomY</code> 的 <code class=\"codespan\">start: 20, end: 80</code> 表示 <code class=\"codespan\">yAxis.min</code> ~ <code class=\"codespan\">yAxis.max</code> 的 <code class=\"codespan\">20%</code> 到 <code class=\"codespan\">80%</code>。</p>\n</li>\n<li><p>如果 <code class=\"codespan\">yAxis.min</code>、<code class=\"codespan\">yAxis.max</code> 没有设置：</p>\n<ul>\n<li><p>如果 <code class=\"codespan\">dataZoomX</code> 设置为 <code class=\"codespan\">filterMode: &#39;empty&#39;</code>：</p>\n<p>  那么 <code class=\"codespan\">dataZoomY</code> 的 <code class=\"codespan\">start: 20, end: 80</code> 表示 series.data 中 <code class=\"codespan\">dataMinY</code> ~ <code class=\"codespan\">dataMaxY</code>（即上例中的 <code class=\"codespan\">9</code> ~ <code class=\"codespan\">80</code>）的 <code class=\"codespan\">20%</code> 到 <code class=\"codespan\">80%</code>。</p>\n</li>\n<li><p>如果 <code class=\"codespan\">dataZoomX</code> 设置为 <code class=\"codespan\">filterMode: &#39;filter&#39;</code>：</p>\n<p>  那么，因为 <code class=\"codespan\">dataZoomX</code> 定义 <code class=\"codespan\">dataZoomY</code> 组件之前，所以 <code class=\"codespan\">dataZoomX</code> 的 <code class=\"codespan\">start: 30, end: 70</code> 表示全部数据的 <code class=\"codespan\">30%</code> 到 <code class=\"codespan\">70%</code>，而 <code class=\"codespan\">dataZoomY</code> 组件的 <code class=\"codespan\">start: 20, end: 80</code> 表示经过 <code class=\"codespan\">dataZoomX</code> 过滤处理后，所得数据集的 <code class=\"codespan\">20%</code> 到 <code class=\"codespan\">80%</code>。</p>\n<p>  如果需要改变这种处理顺序，那么改变 <code class=\"codespan\">dataZoomX</code> 和 <code class=\"codespan\">dataZoomY</code> 在 option 中的出现顺序即可。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><br>\n<br></p>\n<p>下面是详细介绍：</p>\n",
  "dataZoom-inside": "<p><strong>内置型数据区域缩放组件（dataZoomInside）</strong></p>\n<p>（参考<a href=\"#dataZoom\">数据区域缩放组件（dataZoom）的介绍</a>）</p>\n<p>所谓『内置』，即内置在坐标系中。</p>\n<ul>\n<li>平移：在坐标系中滑动拖拽进行数据区域平移。</li>\n<li>缩放：<ul>\n<li>PC端：鼠标在坐标系范围内滚轮滚动（MAC触控板类同）</li>\n<li>移动端：在移动端触屏上，支持两指滑动缩放。</li>\n</ul>\n</li>\n</ul>\n<p><br>\n<br></p>\n",
  "dataZoom-slider": "<p><strong>滑动条型数据区域缩放组件（dataZoomSlider）</strong></p>\n<p>（参考<a href=\"#dataZoom\">数据区域缩放组件（dataZoom）的介绍</a>）</p>\n<p><br>\n<br></p>\n",
  "visualMap": "<p><code class=\"codespan\">visualMap</code> 是视觉映射组件，用于进行『视觉编码』，也就是将数据映射到视觉元素（视觉通道）。</p>\n<p>视觉元素可以是：<br></p>\n<ul>\n<li><code class=\"codespan\">symbol</code>: 图元的图形类别。</li>\n<li><code class=\"codespan\">symbolSize</code>: 图元的大小。</li>\n<li><code class=\"codespan\">color</code>: 图元的颜色。</li>\n<li><code class=\"codespan\">colorAlpha</code>: 图元的颜色的透明度。</li>\n<li><code class=\"codespan\">opacity</code>: 图元以及其附属物（如文字标签）的透明度。</li>\n<li><code class=\"codespan\">colorLightness</code>: 颜色的明暗度，参见 <a href=\"https://en.wikipedia.org/wiki/HSL_and_HSV\" target=\"_blank\">HSL</a>。</li>\n<li><code class=\"codespan\">colorSaturation</code>: 颜色的饱和度，参见 <a href=\"https://en.wikipedia.org/wiki/HSL_and_HSV\" target=\"_blank\">HSL</a>。</li>\n<li><code class=\"codespan\">colorHue</code>: 颜色的色调，参见 <a href=\"https://en.wikipedia.org/wiki/HSL_and_HSV\" target=\"_blank\">HSL</a>。</li>\n</ul>\n<p><code class=\"codespan\">visualMap</code> 组件可以定义多个，从而可以同时对数据中的多个维度进行视觉映射。</p>\n<p><code class=\"codespan\">visualMap</code> 组件可以定义为 <a href=\"#visualMap-piecewise\">分段型（visualMapPiecewise）</a> 或 <a href=\"#visualMap-continuous\">连续型（visualMapContinuous）</a>，通过 <code class=\"codespan\">type</code> 来区分。例如：</p>\n<pre><code class=\"lang-javascript\">option = {\n    visualMap: [\n        { // 第一个 visualMap 组件\n            type: &#39;continuous&#39;, // 定义为连续型 visualMap\n            ...\n        },\n        { // 第二个 visualMap 组件\n            type: &#39;piecewise&#39;, // 定义为分段型 visualMap\n            ...\n        }\n    ],\n    ...\n};\n</code></pre>\n<p><br>\n<strong>✦ 视觉映射方式的配置 ✦</strong></p>\n<p>既然是『数据』到『视觉元素』的映射，<code class=\"codespan\">visualMap</code> 中可以指定数据的『哪个维度』（参见<a href=\"#visualMap.dimension\">visualMap.dimension</a>）映射到哪些『视觉元素』（参见<a href=\"#visualMap.inRange\">visualMap.inRange</a> 和 <a href=\"#visualMap.outOfRange\">visualMap.outOfRange</a>）中。</p>\n<p><br>\n在 visualMap 组件所控制的 series 中，如果 series 中某个数据项需要避开 visualMap 映射，可以这么配置：</p>\n<pre><code>series: {\n    type: &#39;...&#39;,\n    data: [\n        {name: &#39;Shanghai&#39;, value: 251},\n        {name: &#39;Haikou&#39;, value: 21},\n        // 设置 `visualMap: false` 则 visualMap 不对此项进行控制，此时系列\n        // 可使用自身的视觉参数（color/symbol/ ...控制此项的显示。\n        {name: &#39;Beijing&#39;, value: 821, visualMap: false},\n        ...\n    ]\n}\n</code></pre><p><br>\n<strong>✦ 与 ECharts2 中 dataRange 的关系 ✦</strong></p>\n<p><code class=\"codespan\">visualMap</code> 是由 ECharts2 中的 <code class=\"codespan\">dataRange</code> 组件改名以及扩展而来。ECharts3里 <code class=\"codespan\">option</code> 中的 <code class=\"codespan\">dataRange</code> 配置项仍然被兼容，会自动转换成 <code class=\"codespan\">visualMap</code> 配置项。在option中推荐写 <code class=\"codespan\">visualMap</code> 而非 <code class=\"codespan\">dataRange</code>。</p>\n<p><br>\n<strong>✦ 以下是visualMap各组件的详细介绍 ✦</strong></p>\n<p><br>\n<br></p>\n",
  "visualMap-continuous": "<p><strong>连续型视觉映射组件（visualMapContinuous）</strong></p>\n<p>（参考<a href=\"#visualMap\">视觉映射组件（visualMap）的介绍</a>）</p>\n<p><code class=\"codespan\">visualMapContinuous</code>中，可以通过 <a href=\"#visualMap.calculable\">visualMap.calculable</a> 来显示或隐藏手柄（手柄能拖拽改变值域）。</p>\n<p><br>\n<br></p>\n",
  "visualMap-piecewise": "<p><strong>分段型视觉映射组件（visualMapPiecewise）</strong></p>\n<p>（参考<a href=\"#visualMap\">视觉映射组件（visualMap）的介绍</a>）</p>\n<p>展现形式如下图：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/scatter-visualMap-piecewise&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n<p>分段型视觉映射组件，有三种模式：</p>\n<ul>\n<li><strong>连续型数据平均分段</strong>: 依据 <a href=\"#visualMap-piecewise.splitNumber\">visualMap-piecewise.splitNumber</a> 来自动平均分割成若干块。</li>\n<li><strong>连续型数据自定义分段</strong>: 依据 <a href=\"#visualMap-piecewise.pieces\">visualMap-piecewise.pieces</a> 来定义每块范围。</li>\n<li><strong>离散数据根据类别分段</strong>: 类别定义在 <a href=\"#visualMap-piecewise.categories\">visualMap-piecewise.categories</a> 中。</li>\n</ul>\n<p><br>\n<br></p>\n",
  "tooltip": "<p>提示框组件。</p>\n<hr>\n<p><strong>提示框组件的通用介绍：</strong></p>\n<p>提示框组件可以设置在多种地方：</p>\n<ul>\n<li><p>可以设置在全局，即 <a href=\"#tooltip\">tooltip</a></p>\n</li>\n<li><p>可以设置在坐标系中，即 <a href=\"#grid.tooltip\">grid.tooltip</a>、<a href=\"#polar.tooltip\">polar.tooltip</a>、<a href=\"#single.tooltip\">single.tooltip</a></p>\n</li>\n<li><p>可以设置在系列中，即 <a href=\"#series.tooltip\">series.tooltip</a></p>\n</li>\n<li><p>可以设置在系列的每个数据项中，即 <a href=\"#series.data.tooltip\">series.data.tooltip</a></p>\n</li>\n</ul>\n<hr>\n",
  "axisPointer": "<p>这是坐标轴指示器（axisPointer）的全局公用设置。</p>\n<hr>\n<p>坐标轴指示器是指示坐标轴当前刻度的工具。</p>\n<p>如下例，鼠标悬浮到图上，可以出现标线和刻度文本。</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/candlestick-axisPointer&edit=1&reset=1\" width=\"600\" height=\"450\" ></iframe>\n\n\n<p>上例中，使用了 <a href=\"#axisPointer.link\">axisPointer.link</a> 来关联不同的坐标系中的 axisPointer。</p>\n<p>坐标轴指示器也有适合触屏的交互方式，如下：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-tooltip-touch&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p>坐标轴指示器在多轴的场景能起到辅助作用：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=multiple-y-axis&edit=1&reset=1\" width=\"600\" height=\"300\" ></iframe>\n\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=multiple-x-axis&edit=1&reset=1\" width=\"600\" height=\"300\" ></iframe>\n\n\n\n\n<hr>\n<blockquote>\n<p><strong>注意：</strong>\n一般来说，axisPointer 的具体配置项会配置在各个轴中（如 <a href=\"#xAxis.axisPointer\">xAxis.axisPointer</a>）或者 <code class=\"codespan\">tooltip</code> 中（如 <a href=\"#tooltip.axisPointer\">tooltip.axisPointer</a>）。</p>\n<p>但是这几个选项只能配置在全局的 axisPointer 中：<a href=\"#axisPointer.triggerOn\">axisPointer.triggerOn</a>、<a href=\"#axisPointer.link\">axisPointer.link</a>。</p>\n</blockquote>\n<hr>\n<p><strong>如何显示 axisPointer：</strong></p>\n<p>直角坐标系 <a href=\"#grid\">grid</a>、极坐标系 <a href=\"#polar\">polar</a>、单轴坐标系 <a href=\"#single\">single</a> 中的每个轴都自己的 axisPointer。</p>\n<p>他们的 axisPointer 默认不显示。有两种方法可以让他们显示：</p>\n<ul>\n<li><p>设置轴上的 <code class=\"codespan\">axisPointer.show</code>（例如 <a href=\"#xAxis.axisPointer.show\">xAxis.axisPointer.show</a>）为 <code class=\"codespan\">true</code>，则显示此轴的 axisPointer。</p>\n</li>\n<li><p>设置 <a href=\"#tooltip.trigger\">tooltip.trigger</a> 设置为 <code class=\"codespan\">&#39;axis&#39;</code> 或者 <a href=\"#tooltip.axisPointer.type\">tooltip.axisPointer.type</a> 设置为 <code class=\"codespan\">&#39;cross&#39;</code>，则此时坐标系会自动选择显示哪个轴的 axisPointer，也可以使用 <a href=\"#tooltip.axisPointer.axis\">tooltip.axisPointer.axis</a> 改变这种选择。注意，轴上如果设置了 axisPointer，会覆盖此设置。</p>\n</li>\n</ul>\n<hr>\n<p><strong>如何显示 axisPointer 的 label：</strong></p>\n<p>axisPointer 的 label 默认不显示（也就是默认只显示指示线），除非：</p>\n<ul>\n<li><p>设置轴上的 <code class=\"codespan\">axisPointer.label.show</code>（例如 <a href=\"#xAxis.axisPointer.show\">xAxis.axisPointer.label.show</a>）为 <code class=\"codespan\">true</code>，则显示此轴的 axisPointer 的 label。</p>\n</li>\n<li><p>设置 <a href=\"#tooltip.axisPointer.type\">tooltip.axisPointer.type</a> 为 <code class=\"codespan\">&#39;cross&#39;</code> 时会自动显示 axisPointer 的 label。</p>\n</li>\n</ul>\n<hr>\n<p><strong>关于触屏的 axisPointer 的设置</strong></p>\n<p>设置轴上的 <code class=\"codespan\">axisPointer.handle.show</code>（例如 <a href=\"#xAxis.axisPointer.handle.show\">xAxis.axisPointer.handle.show</a> 为 <code class=\"codespan\">true</code> 则会显示出此 axisPointer 的拖拽按钮。（polar 坐标系暂不支持此功能）。</p>\n<p><strong>注意：</strong>\n如果发现此时 tooltip 效果不良好，可设置 <a href=\"#tooltip.triggerOn\">tooltip.triggerOn</a> 为 <code class=\"codespan\">&#39;none&#39;</code>（于是效果为：手指按住按钮则显示 tooltip，松开按钮则隐藏 tooltip），或者 <a href=\"#tooltip.alwaysShowContent\">tooltip.alwaysShowContent</a> 为 <code class=\"codespan\">true</code>（效果为 tooltip 一直显示）。</p>\n<p>参见<a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=line-tooltip-touch&amp;edit=1&amp;reset=1\" target=\"_blank\">例子</a>。</p>\n<hr>\n<p><strong>自动吸附到数据（snap）</strong></p>\n<p>对于数值轴、时间轴，如果开启了 <a href=\"#xAxis.axisPointer.snap\">snap</a>，则 axisPointer 会自动吸附到最近的点上。</p>\n<hr>\n<hr>\n",
  "toolbox": "<p>工具栏。内置有<a href=\"#toolbox.feature.saveAsImage\">导出图片</a>，<a href=\"#toolbox.feature.dataView\">数据视图</a>，<a href=\"#toolbox.feature.magicType\">动态类型切换</a>，<a href=\"#toolbox.feature.dataZoom\">数据区域缩放</a>，<a href=\"#toolbox.feature.reset\">重置</a>五个工具。</p>\n<p><strong>如下示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-marker&reset=1&edit=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n",
  "brush": "<p><code class=\"codespan\">brush</code> 是区域选择组件，用户可以选择图中一部分数据，从而便于向用户展示被选中数据，或者他们的一些统计计算结果。</p>\n<p><br></p>\n<hr>\n<p><strong>刷子的类型和启动按钮</strong></p>\n<p>目前 <code class=\"codespan\">brush</code> 组件支持的图表类型：<code class=\"codespan\">scatter</code>、<code class=\"codespan\">bar</code>、<code class=\"codespan\">candlestick</code>（<code class=\"codespan\">parallel</code> 本身自带刷选功能，但并非由 brush 组件来提供）。</p>\n<p>点击 <code class=\"codespan\">toolbox</code> 中的按钮，能够进行『区域选择』、『清除选择』等操作。</p>\n<p><br>\n<code class=\"codespan\">横向刷子</code> 的示例如下（点击 <code class=\"codespan\">toolbox</code> 中的按钮启动刷选）：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=candlestick-brush&edit=1&reset=1\" width=\"800\" height=\"500\" ></iframe>\n\n\n<p><br>\n<code class=\"codespan\">bar</code> 图中的 <code class=\"codespan\">brush</code>（点击 <code class=\"codespan\">toolbox</code> 中的按钮启动刷选）：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=bar-brush&edit=1&reset=1\" width=\"800\" height=\"400\" ></iframe>\n\n\n\n<p>启动 <code class=\"codespan\">brush</code> 的按钮既可以在 <code class=\"codespan\">toolbox</code> 中指定（参见 <a href=\"#toolbox.feature.brush.type\">toolbox.feature.brush.type</a>），也可以在 <code class=\"codespan\">brush</code> 组件的配置中指定（参见 <a href=\"#brush.toolbox\">brush.toolbox</a>）。</p>\n<p>支持这几种选框：<code class=\"codespan\">矩形刷子</code>，<code class=\"codespan\">任意形状刷子</code>，<code class=\"codespan\">横向刷子</code>，<code class=\"codespan\">纵向刷子</code>。参见 <a href=\"#brush.toolbox\">brush.toolbox</a>。</p>\n<p>可以使用 <code class=\"codespan\">保持选择</code> 按钮，切换单选和多选模式。</p>\n<ul>\n<li>单选即同时只能存在一个选框，可单击空白区域消除选框。</li>\n<li>多选即同时可存在多个选框，单击空白区域不能消除选框，需要点击『清除按钮』消除线框。</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong>刷选和坐标系的关系</strong></p>\n<p>可以设置 <code class=\"codespan\">brush</code> 是『全局的』还是『属于坐标系的』。</p>\n<p><strong>全局 brush</strong></p>\n<p>在 echarts 实例中任意地方刷选。这是默认情况。如果没有指定为『坐标系 brush』，就是『全局 brush』。</p>\n<p><strong>坐标系 brush</strong></p>\n<p>在 指定的坐标系中刷选。选框可以跟随坐标系的缩放和平移（roam 和 dataZoom）而移动。</p>\n<p>坐标系 brush 实际更为常用，尤其是在 geo 中。</p>\n<p>通过指定 <a href=\"#brush.geoIndex\">brush.geoIndex</a> 或 <a href=\"#brush.xAxisIndex\">brush.xAxisIndex</a> 或 <a href=\"#brush.yAxisIndex\">brush.yAxisIndex</a> 来规定可以在哪些坐标系中进行刷选。</p>\n<p>这几个配置项的取值可以是：</p>\n<ul>\n<li><code class=\"codespan\">&#39;all&#39;</code>，表示所有</li>\n<li><code class=\"codespan\">number</code>，如 <code class=\"codespan\">0</code>，表示这个 index 所对应的坐标系。</li>\n<li><code class=\"codespan\">Array</code>，如 <code class=\"codespan\">[0, 4, 2]</code>，表示指定这些 index 所对应的坐标系。</li>\n<li><code class=\"codespan\">&#39;none&#39;</code> 或 <code class=\"codespan\">null</code> 或 <code class=\"codespan\">undefined</code>，表示不指定。</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"lang-javascript\">option = {\n    geo: {\n        ...\n    },\n    brush: {\n        geoIndex: &#39;all&#39;, // 只可以在所有 geo 坐标系中刷选，也就是上面定义的 geo 组件中。\n        ...\n    }\n};\n</code></pre>\n<p>例如：</p>\n<pre><code class=\"lang-javascript\">option = {\n    grid: [\n        {...}, // grid 0\n        {...}  // grid 1\n    ],\n    xAxis: [\n        {gridIndex: 1, ...}, // xAxis 0，属于 grid 1。\n        {gridIndex: 0, ...}  // xAxis 1，属于 grid 0。\n    ],\n    yAxis: [\n        {gridIndex: 1, ...}, // yAxis 0，属于 grid 1。\n        {gridIndex: 0, ...}  // yAxis 1，属于 grid 0。\n    ],\n    brush: {\n        xAxisIndex: [0, 1], // 只可以在 xAxisIndex 为 `0` 和 `1` 的 xAxis 所在的直角坐标系中刷选。\n        ...\n    }\n};\n</code></pre>\n<p><br></p>\n<hr>\n<p><strong> 使用 API 控制选框 </strong></p>\n<p>可以通过调用 <code class=\"codespan\">dispatchAction</code> 来用程序主动渲染选框，例如：</p>\n<pre><code class=\"lang-javascript\">myChart.dispatchAction({\n    type: &#39;brush&#39;,\n    areas: [\n        {\n            geoIndex: 0,\n            // 指定选框的类型。\n            brushType: &#39;polygon&#39;,\n            // 指定选框的形状。\n            coordRange: [[119.72,34.85],[119.68,34.85],[119.5,34.84],[119.19,34.77]]\n        }\n    ]\n});\n</code></pre>\n<p>详情参见 <a href=\"api.html#action.brush\" target=\"_blank\">action.brush</a></p>\n<p><br></p>\n<hr>\n<p><strong> brushLink </strong></p>\n<p>不同系列间，选中的项可以联动。</p>\n<p>参见如下效果（刷选一个 <code class=\"codespan\">scatter</code>，其他 <code class=\"codespan\">scatter</code> 以及 <code class=\"codespan\">parallel</code> 图都会有选中效果）：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=scatter-matrix&edit=1&reset=1\" width=\"800\" height=\"550\" ></iframe>\n\n\n<p><code class=\"codespan\">brushLink</code> 配置项是一个数组，内容是 seriesIndex，指定了哪些 series 可以被联动。例如可以是：</p>\n<ul>\n<li><code class=\"codespan\">[3, 4, 5]</code> 表示 seriesIndex 为 <code class=\"codespan\">3</code>, <code class=\"codespan\">4</code>, <code class=\"codespan\">5</code> 的 series 可以被联动。</li>\n<li><code class=\"codespan\">&#39;all&#39;</code> 表示所有 series 都进行 brushLink。</li>\n<li><code class=\"codespan\">&#39;none&#39;</code> 或 <code class=\"codespan\">null</code> 或 <code class=\"codespan\">undefined</code> 表示不启用 brushLink 功能。</li>\n</ul>\n<p><strong>注意</strong></p>\n<p>brushLink 是通过 dataIndex 进行映射，所以需要保证，<strong>联动的每个系列的 <code class=\"codespan\">data</code> 都是 <code class=\"codespan\">index</code> 对应的</strong>。*</p>\n<p>例如：</p>\n<pre><code class=\"lang-javascript\">option = {\n    brush: {\n        brushLink: [0, 1]\n    },\n    series: [\n        {\n            type: &#39;bar&#39;\n            data: [232,    4434,    545,      654]     // data 有四个项\n        },\n        {\n            type: &#39;parallel&#39;,\n            data: [[4, 5], [3, 5], [66, 33], [99, 66]] // data 同样有四个项，两个系列的 data 是对应的。\n        }\n    ]\n};\n</code></pre>\n<p>参见 <a href=\"#brush.brushLink\">brush.brushLink</a>。</p>\n<p><br></p>\n<hr>\n<p><strong> throttle / debounce / 事件延迟 </strong></p>\n<p>默认情况，刷选或者移动选区的时候，会不断得发 <code class=\"codespan\">brushSelected</code> 事件，从而告诉外界选中的内容。</p>\n<p>但是频繁的事件可能导致性能问题，或者动画效果很差。所以 brush 组件提供了 <a href=\"#brush.throttleType\">brush.throttleType</a>，<a href=\"#brush.throttleDelay\">brush.throttleDelay</a> 来解决这个问题。</p>\n<p>throttleType 取值可以是：</p>\n<ul>\n<li><code class=\"codespan\">&#39;debounce&#39;</code>：表示只有停止动作了（即一段时间没有操作了），才会触发事件。时间阈值由 <a href=\"#brush.throttleDelay\">brush.throttleDelay</a> 指定。</li>\n<li><code class=\"codespan\">&#39;fixRate&#39;</code>：表示按照一定的频率触发事件，时间间隔由 <a href=\"#brush.throttleDelay\">brush.throttleDelay</a> 指定。</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong> 被选中项和未被选中项的视觉设置 </strong></p>\n<p>参见 <a href=\"#brush.inBrush\">brush.inBrush</a> 和 <a href=\"#brush.outOfBrush\">brush.outOfBrush</a>。</p>\n<p><br></p>\n<hr>\n<p>下面是详细配置。</p>\n",
  "geo": "<p>地理坐标系组件。</p>\n<p>地理坐标系组件用于地图的绘制，支持在地理坐标系上绘制<a href=\"#series-scatter\">散点图</a>，<a href=\"#series-lines\">线集</a>。</p>\n<p><code class=\"codespan\">3.1.10</code> 开始 geo 组件也支持鼠标事件。事件参数为</p>\n<pre><code class=\"lang-js\">{\n    componentType: &#39;geo&#39;,\n    // Geo 组件在 option 中的 index\n    geoIndex: number,\n    // 点击区域的名称，比如&quot;上海&quot;\n    name: string,\n    // 传入的点击区域的 region 对象，见 geo.regions\n    region: Object\n}\n</code></pre>\n<p><strong>Tip:</strong>\ngeo 区域的颜色也可以被 map series 所控制，参见 <a href=\"#series-map.geoIndex\">series-map.geoIndex</a>。</p>\n",
  "parallel": "<p><br></p>\n<hr>\n<p><strong>平行坐标系介绍</strong></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Parallel_coordinates\" target=\"_blank\">平行坐标系（Parallel Coordinates）</a> 是一种常用的可视化高维数据的图表。</p>\n<p>例如 <a href=\"#series-parallel.data\">series-parallel.data</a> 中有如下数据：</p>\n<pre><code class=\"lang-javascript\">[\n    [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n    [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n    [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n    [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n    { // 数据项也可以是 Object，从而里面能含有对线条的特殊设置。\n        value: [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;]\n        lineStyle: {...},\n    }\n    ...\n]\n</code></pre>\n<p>数据中，每一行是一个『数据项』，每一列属于一个『维度』。（例如上面数据每一列的含义分别是：『日期』,『AQI指数』, 『PM2.5』, 『PM10』, 『一氧化碳值』, 『二氧化氮值』, 『二氧化硫值』）。</p>\n<p>平行坐标系适用于对这种多维数据进行可视化分析。每一个维度（每一列）对应一个坐标轴，每一个『数据项』是一条线，贯穿多个坐标轴。在坐标轴上，可以进行数据选取等操作。如下：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/parallel-all&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><br></p>\n<hr>\n<p><strong>配置方式概要</strong></p>\n<p>『平行坐标系』的 <code class=\"codespan\">option</code> 基本配置如下例：</p>\n<pre><code class=\"lang-javascript\">option = {\n    parallelAxis: [                     // 这是一个个『坐标轴』的定义\n        {dim: 0, name: schema[0].text}, // 每个『坐标轴』有个 &#39;dim&#39; 属性，表示坐标轴的维度号。\n        {dim: 1, name: schema[1].text},\n        {dim: 2, name: schema[2].text},\n        {dim: 3, name: schema[3].text},\n        {dim: 4, name: schema[4].text},\n        {dim: 5, name: schema[5].text},\n        {dim: 6, name: schema[6].text},\n        {dim: 7, name: schema[7].text,\n            type: &#39;category&#39;,           // 坐标轴也可以支持类别型数据\n            data: [&#39;优&#39;, &#39;良&#39;, &#39;轻度污染&#39;, &#39;中度污染&#39;, &#39;重度污染&#39;, &#39;严重污染&#39;]\n        }\n    ],\n    parallel: {                         // 这是『坐标系』的定义\n        left: &#39;5%&#39;,                     // 平行坐标系的位置设置\n        right: &#39;13%&#39;,\n        bottom: &#39;10%&#39;,\n        top: &#39;20%&#39;,\n        parallelAxisDefault: {          // 『坐标轴』的公有属性可以配置在这里避免重复书写\n            type: &#39;value&#39;,\n            nameLocation: &#39;end&#39;,\n            nameGap: 20\n        }\n    },\n    series: [                           // 这里三个系列共用一个平行坐标系\n        {\n            name: &#39;北京&#39;,\n            type: &#39;parallel&#39;,           // 这个系列类型是 &#39;parallel&#39;\n            data: [\n                [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n                [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;上海&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;广州&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;],\n                ...\n            ]\n        }\n    ]\n};\n</code></pre>\n<p>需要涉及到三个组件：<a href=\"#parallel\">parallel</a>、<a href=\"#parallelAxis\">parallelAxis</a>、<a href=\"#series-parallel\">series-parallel</a></p>\n<ul>\n<li><p><a href=\"#parallel\">parallel</a></p>\n<p>  这个配置项是平行坐标系的『坐标系』本身。一个系列（<code class=\"codespan\">series</code>）或多个系列（如上图中的『北京』、『上海』、『广州』分别各是一个系列）可以共用这个『坐标系』。</p>\n<p>  和其他坐标系一样，坐标系也可以创建多个。</p>\n<p>  位置设置，也是放在这里进行。</p>\n</li>\n<li><p><a href=\"#parallelAxis\">parallelAxis</a></p>\n<p>  这个是『坐标系』中的坐标轴的配置。自然，需要有多个坐标轴。</p>\n<p>  其中有 <a href=\"#parallelAxis.parallelIndex\">parallelAxis.parallelIndex</a> 属性，指定这个『坐标轴』在哪个『坐标系』中。默认使用第一个『坐标系』。</p>\n</li>\n<li><p><a href=\"#series-parallel\">series-parallel</a></p>\n<p>  这个是『系列』的定义。系列被画到『坐标系』上。</p>\n<p>  其中有 <a href=\"#series-parallel.parallelIndex\">series-parallel.parallelIndex</a> 属性，指定使用哪个『坐标系』。默认使用第一个『坐标系』。</p>\n</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong>配置注意和最佳实践</strong></p>\n<p>配置多个 <a href=\"#parallelAxis\">parallelAxis</a> 时，有些值一样的属性，如果书写多遍则比较繁琐，那么可以放置在 <a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里。在坐标轴初始化前，<a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里的配置项，会分别融合进 <a href=\"#parallelAxis\">parallelAxis</a>，形成最终的坐标轴的配置。</p>\n<p><strong>如果数据量很大并且发生卡顿</strong></p>\n<p>建议把 <a href=\"#series-parallel.lineStyle.width\">series-parallel.lineStyle.width</a> 设为 <code class=\"codespan\">0.5</code>（或更小），\n可能显著改善性能。</p>\n<p><br></p>\n<hr>\n<p><strong>高维数据的显示</strong></p>\n<p>维度比较多时，比如有 50+ 的维度，那么就会有 50+ 个轴。那么可能会页面显示不下。</p>\n<p>可以通过 <a href=\"#parallel.axisExpandable\">parallel.axisExpandable</a> 来改善显示效果。</p>\n<p><br>\n<br></p>\n",
  "parallelAxis": "<p>这个组件是平行坐标系中的坐标轴。</p>\n<p><br></p>\n<hr>\n<p><strong>平行坐标系介绍</strong></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Parallel_coordinates\" target=\"_blank\">平行坐标系（Parallel Coordinates）</a> 是一种常用的可视化高维数据的图表。</p>\n<p>例如 <a href=\"#series-parallel.data\">series-parallel.data</a> 中有如下数据：</p>\n<pre><code class=\"lang-javascript\">[\n    [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n    [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n    [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n    [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n    { // 数据项也可以是 Object，从而里面能含有对线条的特殊设置。\n        value: [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;]\n        lineStyle: {...},\n    }\n    ...\n]\n</code></pre>\n<p>数据中，每一行是一个『数据项』，每一列属于一个『维度』。（例如上面数据每一列的含义分别是：『日期』,『AQI指数』, 『PM2.5』, 『PM10』, 『一氧化碳值』, 『二氧化氮值』, 『二氧化硫值』）。</p>\n<p>平行坐标系适用于对这种多维数据进行可视化分析。每一个维度（每一列）对应一个坐标轴，每一个『数据项』是一条线，贯穿多个坐标轴。在坐标轴上，可以进行数据选取等操作。如下：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/parallel-all&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><br></p>\n<hr>\n<p><strong>配置方式概要</strong></p>\n<p>『平行坐标系』的 <code class=\"codespan\">option</code> 基本配置如下例：</p>\n<pre><code class=\"lang-javascript\">option = {\n    parallelAxis: [                     // 这是一个个『坐标轴』的定义\n        {dim: 0, name: schema[0].text}, // 每个『坐标轴』有个 &#39;dim&#39; 属性，表示坐标轴的维度号。\n        {dim: 1, name: schema[1].text},\n        {dim: 2, name: schema[2].text},\n        {dim: 3, name: schema[3].text},\n        {dim: 4, name: schema[4].text},\n        {dim: 5, name: schema[5].text},\n        {dim: 6, name: schema[6].text},\n        {dim: 7, name: schema[7].text,\n            type: &#39;category&#39;,           // 坐标轴也可以支持类别型数据\n            data: [&#39;优&#39;, &#39;良&#39;, &#39;轻度污染&#39;, &#39;中度污染&#39;, &#39;重度污染&#39;, &#39;严重污染&#39;]\n        }\n    ],\n    parallel: {                         // 这是『坐标系』的定义\n        left: &#39;5%&#39;,                     // 平行坐标系的位置设置\n        right: &#39;13%&#39;,\n        bottom: &#39;10%&#39;,\n        top: &#39;20%&#39;,\n        parallelAxisDefault: {          // 『坐标轴』的公有属性可以配置在这里避免重复书写\n            type: &#39;value&#39;,\n            nameLocation: &#39;end&#39;,\n            nameGap: 20\n        }\n    },\n    series: [                           // 这里三个系列共用一个平行坐标系\n        {\n            name: &#39;北京&#39;,\n            type: &#39;parallel&#39;,           // 这个系列类型是 &#39;parallel&#39;\n            data: [\n                [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n                [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;上海&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;广州&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;],\n                ...\n            ]\n        }\n    ]\n};\n</code></pre>\n<p>需要涉及到三个组件：<a href=\"#parallel\">parallel</a>、<a href=\"#parallelAxis\">parallelAxis</a>、<a href=\"#series-parallel\">series-parallel</a></p>\n<ul>\n<li><p><a href=\"#parallel\">parallel</a></p>\n<p>  这个配置项是平行坐标系的『坐标系』本身。一个系列（<code class=\"codespan\">series</code>）或多个系列（如上图中的『北京』、『上海』、『广州』分别各是一个系列）可以共用这个『坐标系』。</p>\n<p>  和其他坐标系一样，坐标系也可以创建多个。</p>\n<p>  位置设置，也是放在这里进行。</p>\n</li>\n<li><p><a href=\"#parallelAxis\">parallelAxis</a></p>\n<p>  这个是『坐标系』中的坐标轴的配置。自然，需要有多个坐标轴。</p>\n<p>  其中有 <a href=\"#parallelAxis.parallelIndex\">parallelAxis.parallelIndex</a> 属性，指定这个『坐标轴』在哪个『坐标系』中。默认使用第一个『坐标系』。</p>\n</li>\n<li><p><a href=\"#series-parallel\">series-parallel</a></p>\n<p>  这个是『系列』的定义。系列被画到『坐标系』上。</p>\n<p>  其中有 <a href=\"#series-parallel.parallelIndex\">series-parallel.parallelIndex</a> 属性，指定使用哪个『坐标系』。默认使用第一个『坐标系』。</p>\n</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong>配置注意和最佳实践</strong></p>\n<p>配置多个 <a href=\"#parallelAxis\">parallelAxis</a> 时，有些值一样的属性，如果书写多遍则比较繁琐，那么可以放置在 <a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里。在坐标轴初始化前，<a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里的配置项，会分别融合进 <a href=\"#parallelAxis\">parallelAxis</a>，形成最终的坐标轴的配置。</p>\n<p><strong>如果数据量很大并且发生卡顿</strong></p>\n<p>建议把 <a href=\"#series-parallel.lineStyle.width\">series-parallel.lineStyle.width</a> 设为 <code class=\"codespan\">0.5</code>（或更小），\n可能显著改善性能。</p>\n<p><br></p>\n<hr>\n<p><strong>高维数据的显示</strong></p>\n<p>维度比较多时，比如有 50+ 的维度，那么就会有 50+ 个轴。那么可能会页面显示不下。</p>\n<p>可以通过 <a href=\"#parallel.axisExpandable\">parallel.axisExpandable</a> 来改善显示效果。</p>\n<p><br>\n<br></p>\n",
  "singleAxis": "<p>单轴。可以被应用到散点图中展现一维数据，如下示例</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=scatter-single-axis&edit=1&reset=1\" width=\"700\" height=\"500\" ></iframe>\n\n\n\n",
  "timeline": "<p><code class=\"codespan\">timeline</code> 组件，提供了在多个 ECharts <code class=\"codespan\">option</code> 间进行切换、播放等操作的功能。</p>\n<p>示例效果如下：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/mix-timeline-all&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><code class=\"codespan\">timeline</code> 和其他组件有些不同，它需要操作『多个option』。\n假设，我们把 ECharts 的传统的 option 称为<em>原子option</em>，那么使用 <code class=\"codespan\">timeline</code> 时，传入 ECharts 的 option 就成为了一个集合多个原子option的<em>复合option</em>。如下示例：</p>\n<pre><code class=\"lang-javascript\">// 如下，baseOption 是一个 『原子option』，options 数组中的每一项也是一个 『原子option』。\n// 每个『原子option』中就是本文档中描述的各种配置项。\nmyChart.setOption(\n    {\n        baseOption: {\n            timeline: {\n                ...,\n                data: [&#39;2002-01-01&#39;, &#39;2003-01-01&#39;, &#39;2004-01-01&#39;]\n            },\n            title: {\n                subtext: &#39;数据来自国家统计局&#39;\n            },\n            grid: {...},\n            xAxis: [...],\n            yAxis: [...],\n            series: [\n                { // 系列一的一些其他配置\n                    type: &#39;bar&#39;,\n                    ...\n                },\n                { // 系列二的一些其他配置\n                    type: &#39;line&#39;,\n                    ...\n                },\n                { // 系列三的一些其他配置\n                    type: &#39;pie&#39;,\n                    ...\n                }\n            ]\n        },\n        options: [\n            { // 这是&#39;2002-01-01&#39; 对应的 option\n                title: {\n                    text: &#39;2002年统计值&#39;\n                },\n                series: [\n                    {data: []}, // 系列一的数据\n                    {data: []}, // 系列二的数据\n                    {data: []}  // 系列三的数据\n                ]\n            },\n            { // 这是&#39;2003-01-01&#39; 对应的 option\n                title: {\n                    text: &#39;2003年统计值&#39;\n                },\n                series: [\n                    {data: []},\n                    {data: []},\n                    {data: []}\n                ]\n            },\n            { // 这是&#39;2004-01-01&#39; 对应的 option\n                title: {\n                    text: &#39;2004年统计值&#39;\n                },\n                series: [\n                    {data: []},\n                    {data: []},\n                    {data: []}\n                ]\n            }\n        ]\n    }\n);\n</code></pre>\n<p>在上例中，<code class=\"codespan\">timeline.data</code> 中的每一项，对应于 <code class=\"codespan\">options</code> 数组中的每个 <code class=\"codespan\">option</code>。</p>\n<p><br>\n<strong>使用注意与最佳实践：</strong></p>\n<ul>\n<li><p>公有的配置项，推荐配置在 <code class=\"codespan\">baseOption</code> 中。<code class=\"codespan\">timeline</code> 播放切换时，会把 <code class=\"codespan\">options</code> 数组中的对应的 <code class=\"codespan\">option</code>，与 <code class=\"codespan\">baseOption</code> 进行 merge 形成最终的 <code class=\"codespan\">option</code>。</p>\n</li>\n<li><p><code class=\"codespan\">options</code> 数组中，如果某一数组项中配置了某个属性，那么其他数组项中也必须配置某个属性，而不能缺省。否则这个属性的执行效果会遗留。</p>\n</li>\n<li><p><em>复合 option</em> 中的 <code class=\"codespan\">options</code> 不支持 merge。</p>\n<p>  也就是说，当第二（或三、四、五 ...）次 <code class=\"codespan\">chart.setOption(rawOption)</code> 时，如果 <code class=\"codespan\">rawOption</code> 是<em>复合 option</em>（即包含 <code class=\"codespan\">options</code> 列表），那么新的 <code class=\"codespan\">rawOption.options</code> 列表不会和老的 <code class=\"codespan\">options</code> 列表进行 merge，而是简单替代。当然，<code class=\"codespan\">rawOption.baseOption</code> 仍然会正常和老的 option 进行merge。</p>\n</li>\n</ul>\n<p><br>\n<strong>与 ECharts 2 的兼容性：</strong></p>\n<ul>\n<li><p>ECharts 3 中不再支持 timeline.notMerge 参数，也就是不支持 notMerge 模式。如果遇到这种场景需要使用，可在外部进行option管理，并用 setOption(option, true) 这样的notMerge方式设置。</p>\n</li>\n<li><p>ECharts 3 和 ECharts 2 相比，timeline 属性的定义位置有所不同，移到了 <code class=\"codespan\">baseOption</code> 中，统一作为一个普通的组件看待。但是，仍然兼容 ECharts2 的 timeline 定义位置，只是不再推荐这样写。</p>\n</li>\n</ul>\n",
  "graphic": "<p><code class=\"codespan\">graphic</code> 是原生图形元素组件。可以支持的图形元素包括：</p>\n<p><a href=\"#graphic.elementsimage\">image</a>,\n<a href=\"#graphic.elementstext\">text</a>,\n<a href=\"#graphic.elementscircle\">circle</a>,\n<a href=\"#graphic.elementssector\">sector</a>,\n<a href=\"#graphic.elementsring\">ring</a>,\n<a href=\"#graphic.elementspolygon\">polygon</a>,\n<a href=\"#graphic.elementspolyline\">polyline</a>,\n<a href=\"#graphic.elementsrect\">rect</a>,\n<a href=\"#graphic.elementsline\">line</a>,\n<a href=\"#graphic.elementsbezierCurve\">bezierCurve</a>,\n<a href=\"#graphic.elementsarc\">arc</a>,\n<a href=\"#graphic.elementsgroup\">group</a>,</p>\n<p>下面示例中，使用图形元素做了水印，和文本块：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-graphic&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p>下面示例中，使用隐藏的图形元素实现了拖拽：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-draggable&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n\n<p><br></p>\n<hr>\n<p><strong>graphic 设置介绍</strong></p>\n<p>只配一个图形元素时的简写方法：</p>\n<pre><code class=\"lang-javascript\">myChart.setOption({\n    ...,\n    graphic: {\n        type: &#39;image&#39;,\n        ...\n    }\n});\n</code></pre>\n<p>配多个图形元素：</p>\n<pre><code class=\"lang-javascript\">myChart.setOption({\n    ...,\n    graphic: [\n        { // 一个图形元素，类型是 image。\n            type: &#39;image&#39;,\n            ...\n        },\n        { // 一个图形元素，类型是 text，指定了 id。\n            type: &#39;text&#39;,\n            id: &#39;text1&#39;,\n            ...\n        },\n        { // 一个图形元素，类型是 group，可以嵌套子节点。\n            type: &#39;group&#39;,\n            children: [\n                {\n                    type: &#39;rect&#39;,\n                    id: &#39;rect1&#39;,\n                    ...\n                },\n                {\n                    type: &#39;image&#39;,\n                    ...\n                },\n                ...\n            ]\n        }\n        ...\n    ]\n});\n</code></pre>\n<p>使用 setOption 来删除或更换（替代）已有的图形元素：</p>\n<pre><code class=\"lang-javascript\">myChart.setOption({\n    ...,\n    graphic: [\n        { // 删除上例中定义的 &#39;text1&#39; 元素。\n            id: &#39;text1&#39;,\n            $action: &#39;remove&#39;,\n            ...\n        },\n        { // 将上例中定义的 &#39;rect1&#39; 元素换成 circle。\n          // 注意尽管 &#39;rect1&#39; 在一个 group 中，但这里并不需要顾忌层级，用id指定就可以了。\n            id: &#39;rect1&#39;,\n            $action: &#39;replace&#39;,\n            type: &#39;circle&#39;,\n            ...\n        }\n    ]\n});\n</code></pre>\n<p>注意，如果没有指定 id，第二次 setOption 时会按照元素在 option 中出现的顺序和已有的图形元素进行匹配。这有时会产生不易理解的效果。\n所以，一般来说，更新 elements 时推荐使用 id 进行准确的指定，而非省略 id。</p>\n<p><br></p>\n<hr>\n<p><strong>图形元素设置介绍</strong></p>\n<p>介绍每个图形元素的配置。不同类型的图形元素的设置有这些共性：</p>\n<pre><code class=\"lang-javascript\">{\n    // id 用于在更新图形元素时指定更新哪个图形元素，如果不需要用可以忽略。\n    id: &#39;xxx&#39;,\n\n    // 这个字段在第一次设置时不能忽略，取值见上方『支持的图形元素』。\n    type: &#39;image&#39;,\n\n    // 下面的各个属性如果不需要设置都可以忽略，忽略则取默认值。\n\n    // 指定本次 setOption 对此图形元素进行的操作。默认是 &#39;merge&#39;，还可以 &#39;replace&#39; 或 &#39;remove&#39;。\n    $action: &#39;replace&#39;,\n\n    // 这是四个相对于父元素的定位属性，每个属性可取『像素值』或者『百分比』或者 &#39;center&#39;/&#39;middle&#39;。\n    left: 10,\n    // right: 10,\n    top: &#39;center&#39;,\n    // bottom: &#39;10%&#39;,\n\n    shape: {\n        // 定位、形状相关的设置，如 x, y, cx, cy, width, height, r, points 等。\n        // 注意，如果设置了 left/right/top/bottom，这里的定位用的 x/y/cx/cy 会失效。\n    },\n\n    style: {\n        // 样式相关的设置，如 fill, stroke, lineWidth, shadowBlur 等。\n    },\n\n    // 表示 z 高度，从而指定了图形元素的覆盖关系。\n    z: 10,\n    // 表示不响应事件。\n    silent: true,\n    // 表示节点不显示\n    invisible: false,\n    // 设置是否整体限制在父节点范围内。可选值：&#39;raw&#39;, &#39;all&#39;。\n    bouding: &#39;raw&#39;,\n    // 是否可以被拖拽。\n    draggable: false,\n    // 事件的监听器，还可以是 onmousemove, ondrag 等。支持的事件参见下。\n    onclick: function () {...}\n}\n</code></pre>\n<p><br></p>\n<hr>\n<p><strong>图形元素的事件</strong></p>\n<p>支持这些事件配置：\n<code class=\"codespan\">onclick</code>, <code class=\"codespan\">onmouseover</code>, <code class=\"codespan\">onmouseout</code>, <code class=\"codespan\">onmousemove</code>, <code class=\"codespan\">onmousewheel</code>, <code class=\"codespan\">onmousedown</code>, <code class=\"codespan\">onmouseup</code>, <code class=\"codespan\">ondrag</code>, <code class=\"codespan\">ondragstart</code>, <code class=\"codespan\">ondragend</code>, <code class=\"codespan\">ondragenter</code>, <code class=\"codespan\">ondragleave</code>, <code class=\"codespan\">ondragover</code>, <code class=\"codespan\">ondrop</code>。</p>\n<p><br></p>\n<hr>\n<p><strong>图形元素的层级关系</strong></p>\n<p>只有 <code class=\"codespan\">group</code> 元素可以有子节点，从而以该 <code class=\"codespan\">group</code> 元素为根的元素树可以共同定位（共同移动）。</p>\n<p><br></p>\n<hr>\n<p><strong>图形元素的基本形状设置</strong></p>\n<p>每个图形元素本身有自己的图形基本的位置和尺寸设置，例如：</p>\n<pre><code class=\"lang-javascript\">{\n    type: &#39;rect&#39;,\n    shape: {\n        x: 10,\n        y: 10,\n        width: 100,\n        height: 200\n    }\n},\n{\n    type: &#39;circle&#39;,\n    shape: {\n        cx: 20,\n        cy: 30,\n        r: 100\n    }\n},\n{\n    type: &#39;image&#39;,\n    style: {\n        image: &#39;http://xxx.xxx.xxx/a.png&#39;,\n        x: 100,\n        y: 200,\n        width: 230,\n        height: 400\n    }\n},\n{\n    type: &#39;text&#39;,\n    style: {\n        text: &#39;This text&#39;,\n        x: 100,\n        y: 200\n    }\n\n}\n</code></pre>\n<p><br></p>\n<hr>\n<p><strong>图形元素的定位和 transfrom</strong></p>\n<p>除此以外，可以以 transform 的方式对图形进行平移、旋转、缩放，\n参见：<a href=\"#graphic.elements.position\">position</a>、<a href=\"#graphic.elements.rotation\">rotation</a>、<a href=\"#graphic.elements.scale\">scale</a>、<a href=\"#graphic.elements.origin\">origin</a>。</p>\n<pre><code class=\"lang-javascript\">{\n    type: &#39;rect&#39;,\n    position: [100, 200], // 平移，默认值为 [0, 0]。\n    scale: [2, 4], // 缩放，默认值为 [1, 1]。表示缩放的倍数。\n    rotation: Math.PI / 4, // 旋转，默认值为 0。表示旋转的弧度值。正值表示逆时针旋转。\n    origin: [10, 20], // 旋转和缩放的中心点，默认值为 [0, 0]。\n    shape: {\n        // ...\n    }\n}\n</code></pre>\n<ul>\n<li>每个图形元素在父节点的坐标系中进行 transform，也就是说父子节点的 transform 能『叠加』。</li>\n<li>每个图形元素进行 transform 顺序是：<ol>\n<li>平移 [-el.origin[0], -el.origin[1]]。</li>\n<li>根据 el.scale 缩放。</li>\n<li>根据 el.rotation 旋转。</li>\n<li>根据 el.origin 平移。</li>\n<li>根据 el.position 平移。</li>\n</ol>\n</li>\n<li>也就是说先缩放旋转后平移，这样平移不会影响缩放旋转的 origin。</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong>图形元素相对定位</strong></p>\n<p>以上两者是基本的绝对定位，除此之外，在实际应用中，容器尺寸常常是不确定甚至动态变化的，所以需要提供相对定位的机制。graphic 组件使用 <a href=\"#graphic.elements.left\">left</a> / <a href=\"#graphic.elements.right\">right</a> / <a href=\"#graphic.elements.top\">top</a> / <a href=\"#graphic.elements.bottom\">bottom</a> / <a href=\"#graphic.elements.width\">width</a> / <a href=\"#graphic.elements.height\">height</a> 提供了相对定位的机制。</p>\n<p>例如：</p>\n<pre><code class=\"lang-javascript\">{ // 将图片定位到最下方的中间：\n    type: &#39;image&#39;,\n    left: &#39;center&#39;, // 水平定位到中间\n    bottom: &#39;10%&#39;,  // 定位到距离下边界 10% 处\n    style: {\n        image: &#39;http://xxx.xxx.xxx/a.png&#39;,\n        width: 45,\n        height: 45\n    }\n},\n{ // 将旋转过的 group 整体定位右下角：\n    type: &#39;group&#39;,\n    right: 0,  // 定位到右下角\n    bottom: 0, // 定位到右下角\n    rotation: Math.PI / 4,\n    children: [\n        {\n            type: &#39;rect&#39;,\n            left: &#39;center&#39;, // 相对父元素居中\n            top: &#39;middle&#39;,  // 相对父元素居中\n            shape: {\n                width: 190,\n                height: 90\n            },\n            style: {\n                fill: &#39;#fff&#39;,\n                stroke: &#39;#999&#39;,\n                lineWidth: 2,\n                shadowBlur: 8,\n                shadowOffsetX: 3,\n                shadowOffsetY: 3,\n                shadowColor: &#39;rgba(0,0,0,0.3)&#39;\n            }\n        },\n        {\n            type: &#39;text&#39;,\n            left: &#39;center&#39;, // 相对父元素居中\n            top: &#39;middle&#39;,  // 相对父元素居中\n            style: {\n                fill: &#39;#777&#39;,\n                text: [\n                    &#39;This is text&#39;,\n                    &#39;这是一段文字&#39;,\n                    &#39;Print some text&#39;\n                ].join(&#39;\\n&#39;),\n                font: &#39;14px Microsoft YaHei&#39;\n            }\n        }\n    ]\n}\n</code></pre>\n<p>注意，可以用 <a href=\"graphic.elements.bounding\" target=\"_blank\">bounding</a> 来设置是否整体限制在父节点范围内。</p>\n<p><br></p>\n<hr>\n<p>下面是详细配置。</p>\n",
  "calendar": "<p>日历坐标系组件。</p>\n<p>在ECharts中，我们非常有创意地实现了日历图，是通过使用日历坐标系组件来达到日历图效果的，如下方的几个示例图所示，我们可以在热力图、散点图、关系图中使用日历坐标系。</p>\n<p>在日历坐标系中使用热力图的示例:</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=calendar-heatmap&edit=1&reset=1\" width=\"800\" height=\"400\" ></iframe>\n\n\n<p>在日历坐标系中使用散点图的示例:</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=calendar-effectscatter&edit=1&reset=1\" width=\"800\" height=\"600\" ></iframe>\n\n\n<p>在日历坐标系中使用关系图（以及混合图表）的示例:</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=calendar-graph&edit=1&reset=1\" width=\"600\" height=\"600\" ></iframe>\n\n\n<p>灵活利用 echarts 图表和坐标系的组合，以及 API，可以实现更丰富的效果。\n<a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=calendar-lunar&amp;edit=1&amp;reset=1\" target=\"_blank\">在日历中使用文字</a>、\n<a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=calendar-pie&amp;edit=1&amp;reset=1\" target=\"_blank\">在日历中放置饼图</a></p>\n<hr>\n<p><strong>水平和垂直放置日历</strong></p>\n<p>在日历坐标系可以水平放置，也可以垂直放置。如上面的例子，使用热力图时，经常是水平放置的。但是如果需要格子的尺寸大些，水平放置就过于宽了，于是也可以选择垂直放置。参见 <a href=\"#calendar.orient\">calendar.orient</a>。</p>\n<hr>\n<p><strong>尺寸的自适应</strong></p>\n<p>可以设置日历坐标系使他支持不同尺寸的容器（页面）大小变化的自适应。首先，和 echarts 其他组件一样，日历坐标系可以选择使用 <a href=\"#calendar.left\">left</a> <a href=\"#calendar.right\">right</a> <a href=\"#calendar.top\">top</a> <a href=\"bottom\" target=\"_blank\">bottom</a> <a href=\"#calendar.width\">width</a> <a href=\"#calendar.height\">height</a> 来描述尺寸和位置，从而将日历摆放在上下左右各种位置，并随着页面尺寸变动而改变自身尺寸。另外，也可以使用 <a href=\"#calendar.cellSize\">cellSize</a> 来固定日历格子的长宽。</p>\n<hr>\n<p><strong>中西方日历习惯的支持</strong></p>\n<p>中西方日历有所差别，西方常使用星期日作为一周的第一天，中国使用星期一为一周的第一天。日历坐标系做了这种切换的支持。参见 <a href=\"#calendar.dayLabel.firstDay\">calendar.dayLabel.firstDay</a>。</p>\n<p>另外，日历上的『月份』和『星期几』的文字，也可以较方便的切换中英文，甚至自定义。参见 <a href=\"#calendar.dayLabel.nameMap\">calendar.dayLabel.nameMap</a> <a href=\"#calendar.monthLabel.nameMap\">calendar.monthLabel.nameMap</a>。</p>\n<hr>\n",
  "dataset": "<p>ECharts 4 开始支持了 <code class=\"codespan\">数据集</code>（<code class=\"codespan\">dataset</code>）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这在不少场景下能带来使用上的方便。</p>\n<p>关于 <code class=\"codespan\">dataset</code> 的详情，请参见<a href=\"http://echarts.baidu.com/tutorial.html#%E4%BD%BF%E7%94%A8%20dataset%20%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE\" target=\"_blank\">教程</a>。</p>\n<hr>\n",
  "aria": "<p>W3C 制定了无障碍富互联网应用规范集（<a href=\"https://www.w3.org/WAI/intro/aria\" target=\"_blank\">WAI-ARIA</a>，the Accessible Rich Internet Applications Suite），致力于使得网页内容和网页应用能够被更多残障人士访问。ECharts 4.0 遵从这一规范，支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问。</p>\n<p>默认关闭，需要通过将 <a href=\"#aria.show\">aria.show</a> 设置为 <code class=\"codespan\">true</code> 开启。开启后，会根据图表、数据、标题等情况，自动智能生成关于图表的描述，用户也可以通过配置项修改描述。</p>\n<p><strong>例子：</strong></p>\n<p>对于配置项：</p>\n<pre><code class=\"lang-js\">option = {\n    aria: {\n        show: true\n    },\n    title: {\n        text: &#39;某站点用户访问来源&#39;,\n        x: &#39;center&#39;\n    },\n    series: [\n        {\n            name: &#39;访问来源&#39;,\n            type: &#39;pie&#39;,\n            data: [\n                { value: 335, name: &#39;直接访问&#39; },\n                { value: 310, name: &#39;邮件营销&#39; },\n                { value: 234, name: &#39;联盟广告&#39; },\n                { value: 135, name: &#39;视频广告&#39; },\n                { value: 1548, name: &#39;搜索引擎&#39; }\n            ]\n        }\n    ]\n};\n</code></pre>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/aria-pie&edit=1&reset=1\" width=\"700\" height=\"300\" ></iframe>\n\n\n<p>生成的图表 DOM 上，会有一个 <code class=\"codespan\">aria-label</code> 属性，在朗读设备的帮助下，盲人能够了解图表的内容。其值为：</p>\n<blockquote>\n<p>这是一个关于“某站点用户访问来源”的图表。图表类型是饼图，表示访问来源。其数据是——直接访问的数据是335，邮件营销的数据是310，联盟广告的数据是234，视频广告的数据是135，搜索引擎的数据是1548。</p>\n</blockquote>\n<p>生成描述的基本流程为，如果 <a href=\"#aria.show\">aria.show</a> 设置为 <code class=\"codespan\">true</code>，则生成无障碍访问描述，否则不生成。如果定义了 <a href=\"#aria.description\">aria.description</a>，则将其作为图表的完整描述，否则根据模板拼接生成描述。我们提供了默认的生成描述的算法，仅当生成的描述不太合适时，才需要修改这些模板，甚至使用 <code class=\"codespan\">aria.description</code> 完全覆盖。</p>\n<p>使用模板拼接时，先根据是否存在标题 <a href=\"#title.text\">title.text</a> 决定使用 <a href=\"#aria.general.withTitle\">aria.general.withTitle</a> 还是 <a href=\"#aria.general.withoutTitle\">aria.general.withoutTitle</a> 作为整体性描述。其中，<code class=\"codespan\">aria.general.withTitle</code> 配置项包括模板变量 <code class=\"codespan\">&#39;{title}&#39;</code>，将会被替换成图表标题。也就是说，如果 <code class=\"codespan\">aria.general.withTitle</code> 被设置为 <code class=\"codespan\">&#39;图表的标题是：{title}。&#39;</code>，则如果包含标题 <code class=\"codespan\">&#39;价格分布图&#39;</code>，这部分的描述为 <code class=\"codespan\">&#39;图表的标题是：价格分布图。&#39;</code>。</p>\n<p>拼接完标题之后，会依次拼接系列的描述（<a href=\"#aria.series\">aria.series</a>），和每个系列的数据的描述（<a href=\"#aria.data\">aria.data</a>）。同样，每个模板都有可能包括模板变量，用以替换实际的值。</p>\n<p>完整的描述生成流程为：</p>\n<p><img width=\"800\" height=\"auto\" src=\"documents/asset/img/echarts-aria.jpg\"></p>\n",
  "series": "<p>系列列表。每个系列通过 <code class=\"codespan\">type</code> 决定自己的图表类型</p>\n",
  "series-line": "<p><strong>折线/面积图</strong></p>\n<p>折线图是用折线将各个数据点<a href=\"#series-line.symbol\">标志</a>连接起来的图表，用于展现数据的变化趋势。可用于<a href=\"#grid\">直角坐标系</a>和<a href=\"#polar\">极坐标系</a>上。</p>\n<p><strong>Tip:</strong> 设置 <a href=\"#series-line.areaStyle\">areaStyle</a> 后可以绘制面积图。</p>\n<p><strong>Tip:</strong> 配合分段型 <a href=\"#visualMap-piecewise\">visualMap</a> 组件可以将折线/面积图通过不同颜色分区间。如下示例</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=line-aqi&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n",
  "series-bar": "<p><strong>柱状/条形图</strong></p>\n<p>柱状/条形图 通过 柱形的高度/条形的宽度 来表现数据的大小，用于有至少一个类目轴或时间轴的<a href=\"#grid\">直角坐标系</a>上。</p>\n",
  "series-pie": "<p><strong>饼图</strong></p>\n<p>饼图主要用于表现不同类目的数据在总和中的占比。每个的弧度表示数据数量的比例。</p>\n<p><strong>Tip:</strong> 饼图更适合表现数据相对于总数的百分比等关系。如果只是表示不同类目数据间的大小，建议使用 <a href=\"bar\" target=\"_blank\">柱状图</a>，人们对于微小的弧度差别相比于微小的长度差别更不敏感，或者也可以通过配置 <a href=\"#series-pie.roseType\">roseType</a> 显示成南丁格尔图，通过半径大小区分数据的大小。</p>\n<p><strong>下面是自定义南丁格尔图的示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=pie-custom&edit=1&reset=1\" width=\"500\" height=\"400\" ></iframe>\n\n",
  "series-scatter": "<p>散点（气泡）图。<a href=\"#grid\">直角坐标系</a>上的散点图可以用来展现数据的 <code class=\"codespan\">x</code>，<code class=\"codespan\">y</code> 之间的关系，如果数据项有多个维度，其它维度的值可以通过不同大小的 <a href=\"#series-scatter.symbol\">symbol</a> 展现成气泡图，也可以用颜色来表现。这些可以配合 <a href=\"#visualMap\">visualMap</a> 组件完成。</p>\n<p>可以应用在<a href=\"#grid\">直角坐标系</a>，<a href=\"#polar\">极坐标系</a>，<a href=\"#geo\">地理坐标系</a>上。</p>\n",
  "series-effectScatter": "<p>带有涟漪特效动画的散点（气泡）图。利用动画特效可以将某些想要突出的数据进行视觉突出。</p>\n<p><strong>Tip:</strong> ECharts 2.x 中在地图上通过 markPoint 实现地图特效在 ECharts 3 中建议通过地理坐标系上的 effectScatter 实现。</p>\n",
  "series-radar": "<p><strong>雷达图</strong></p>\n<p>雷达图主要用于表现多变量的数据，例如球员的各个属性分析。依赖 <a href=\"#radar\">radar</a> 组件。</p>\n<p>下面是 AQI 数据用雷达图表现的示例。</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=radar-aqi&edit=1&reset=1\" width=\"600\" height=\"500\" ></iframe>\n\n",
  "series-tree": "<p><strong>树图</strong></p>\n<p>树图主要用来可视化树形数据结构，是一种特殊的层次类型，具有唯一的根节点，左子树，和右子树。</p>\n<p><strong>注意：目前不支持在单个 series 中直接绘制森林，可以通过在一个 option 中配置多个 series 实现森林</strong></p>\n<p><strong>树图示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=tree-vertical&edit=1&reset=1\" width=\"900\" height=\"780\" ></iframe>\n\n\n<p><strong>多个 series 组合成森林示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=tree-legend&edit=1&reset=1\" width=\"800\" height=\"680\" ></iframe>\n\n",
  "series-treemap": "<p><a href=\"https://en.wikipedia.org/wiki/Treemapping\" target=\"_blank\">Treemap</a> 是一种常见的表达『层级数据』『树状数据』的可视化形式。它主要用面积的方式，便于突出展现出『树』的各层级中重要的节点。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=treemap-obama&edit=1&reset=1\" width=\"700\" height=\"580\" ></iframe>\n\n\n\n<p><br>\n<strong>视觉映射：</strong></p>\n<p>treemap 首先是把数值映射到『面积』这种视觉元素上。</p>\n<p>此外，也支持对数据的其他维度进行视觉映射，例如映射到颜色、颜色明暗度上。</p>\n<p>关于视觉设置，详见 <a href=\"#series-treemap.levels\">series-treemap.levels</a>。</p>\n<p><br>\n<strong>下钻（drill down）：</strong></p>\n<p><code class=\"codespan\">drill down</code> 功能即点击后才展示子层级。\n设置了 <a href=\"#series-treemap.leafDepth\">leafDepth</a> 后，下钻（<code class=\"codespan\">drill down</code>）功能开启。</p>\n<p><strong>如下是 drill down 的例子：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=treemap-drill-down&edit=1&reset=1\" width=\"800\" height=\"500\" ></iframe>\n\n\n\n<p><br>\n<br>\n<br>\n注：treemap 的配置项 和 ECharts2 相比有一些变化，一些不太成熟的配置方式不再支持或不再兼容：</p>\n<ul>\n<li><p><code class=\"codespan\">center/size</code> 方式的定位不再支持，而是统一使用 <code class=\"codespan\">left/top/bottom/right/width/height</code> 方式定位。</p>\n</li>\n<li><p><code class=\"codespan\">breadcrumb</code> 的配置被移动到了 <code class=\"codespan\">itemStyle/itemStyle.emphasis</code> 外部，和 <code class=\"codespan\">itemStyle</code> 平级。</p>\n</li>\n<li><p><code class=\"codespan\">root</code> 的设置暂时不支持。目前可以使用 <code class=\"codespan\">zoom</code> 的方式来查看树更下层次的细节，或者使用 <a href=\"#series-treemap.leafDepth\">leafDepth</a> 开启 &quot;drill down&quot; 功能。</p>\n</li>\n<li><p><code class=\"codespan\">label</code> 的配置被移动到了 <code class=\"codespan\">itemStyle/itemStyle.emphasis</code> 外部，和 <code class=\"codespan\">itemStyle</code> 平级。</p>\n</li>\n<li><p><code class=\"codespan\">itemStyle.childBorderWidth</code>、<code class=\"codespan\">itemStyle.childBorderColor</code>不再支持（因为这个配置方式只能定义两层的treemap）。统一使用 <a href=\"#series-treemap.levels\">series-treemap.levels</a> 来进行各层级的定义。</p>\n</li>\n</ul>\n<p><br>\n<br></p>\n",
  "series-sunburst": "<p><a href=\"https://en.wikipedia.org/wiki/Pie_chart#Ring_chart_/_Sunburst_chart_/_Multilevel_pie_chart\" target=\"_blank\">旭日图（Sunburst）</a>由多层的环形图组成，在数据结构上，内圈是外圈的父节点。因此，它既能像<a href=\"#series-pie\">饼图</a>一样表现局部和整体的占比，又能像<a href=\"#series-treemap\">矩形树图</a>一样表现层级关系。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=sunburst-monochrome&edit=1&reset=1\" width=\"700\" height=\"500\" ></iframe>\n\n\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=sunburst-drink&edit=1&reset=1\" width=\"700\" height=\"700\" ></iframe>\n\n\n<p><strong>数据下钻</strong></p>\n<p>旭日图默认支持数据下钻，也就是说，当用户点击了某个扇形块之后，将会以该节点作为根结点显示，并且在中间出现一个返回上层节点的圆。如果不希望有数据下钻功能，可以通过将 <a href=\"#series-treemap.nodeClick\">series-sunburst.nodeClick</a> 设置为 <code class=\"codespan\">false</code> 实现。</p>\n",
  "series-boxplot": "<p><a href=\"https://en.wikipedia.org/wiki/Box_plot\" target=\"_blank\">Boxplot</a> 中文可以称为『箱形图』、『盒须图』、『盒式图』、『盒状图』、『箱线图』，是一种用作显示一组数据分散情况资料的统计图。它能显示出一组数据的最大值、最小值、中位数、下四分位数及上四分位数。</p>\n<p><strong>示例如下：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=boxplot-light-velocity&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><br>\n也支持多个 <code class=\"codespan\">series</code> 在同一个坐标系中，参见 <a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=boxplot-multi&amp;edit=1&amp;reset=1\" target=\"_blank\">例子</a>。</p>\n<p><br>\n<br></p>\n",
  "series-candlestick": "<p><a href=\"https://en.wikipedia.org/wiki/Candlestick_chart\" target=\"_blank\">Candlestick</a> 即我们常说的 <code class=\"codespan\">K线图</code>。</p>\n<p>在 ECharts3 中，同时支持 <code class=\"codespan\">&#39;candlestick&#39;</code> 和 <code class=\"codespan\">&#39;k&#39;</code>这两种 <code class=\"codespan\">&#39;series.type&#39;</code>（<code class=\"codespan\">&#39;k&#39;</code> 会被自动转为 <code class=\"codespan\">&#39;candlestick&#39;</code>）。</p>\n<p><strong>示例如下：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=candlestick-sh&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n\n<p><br>\n<strong>关于『涨』『跌』的颜色：</strong></p>\n<p>不同国家或地区对于 K线图 的颜色定义不一样，可能是『红涨绿跌』或『红涨蓝跌』（如大陆、台湾、日本、韩国等），可能是『绿涨红跌』（如西方国家、香港、新加坡等）。K线图也不一定要用红蓝、红绿来表示涨跌，也可以是『有色/无色』等表示方法。</p>\n<p>默认配置项，采用的是『红涨蓝跌』。如果想更改这个颜色配置，在这些配置项中更改即可：</p>\n<ul>\n<li><a href=\"#series-candlestick.itemStyle.color\">series-candlestick.itemStyle.color</a>：阳线填充色（即『涨』）</li>\n<li><a href=\"#series-candlestick.itemStyle.color0\">series-candlestick.itemStyle.color0</a>：阴线填充色（即『跌』）</li>\n<li><a href=\"#series-candlestick.itemStyle.borderColor\">series-candlestick.itemStyle.borderColor</a>：阳线边框色（即『涨』）</li>\n<li><a href=\"series-candlestick.itemStyle.borderColor0\" target=\"_blank\">series-candlestick.itemStyle.borderColor0</a>：阴线边框色（即『跌』）</li>\n</ul>\n<p><br>\n<br></p>\n",
  "series-heatmap": "<p><strong>热力图</strong></p>\n<p>热力图主要通过颜色去表现数值的大小，必须要配合 <a href=\"#visualMap\">visualMap</a> 组件使用。</p>\n<p>可以应用在<a href=\"#grid\">直角坐标系</a>以及<a href=\"#geo\">地理坐标系</a>上，这两个坐标系上的表现形式相差很大，直角坐标系上必须要使用两个类目轴。</p>\n<p>下面是在直角坐标系上应用的例子：</p>\n<p><strong>直角坐标系：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=heatmap-cartesian&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n",
  "series-map": "<p><strong>地图。</strong></p>\n<p>地图主要用于地理区域数据的可视化，配合 <a href=\"#visualMap\">visualMap</a> 组件用于展示不同区域的人口分布密度等数据。</p>\n<p>多个<a href=\"#series-map.map\">地图类型</a>相同的系列会在同一地图上显示，这时候使用第一个系列的配置项作为地图绘制的配置。</p>\n<p><strong>Tip: </strong>在 ECharts 3 中不再建议在地图类型的图表使用 <code class=\"codespan\">markLine</code> 和 <code class=\"codespan\">markPoint</code>。如果要实现点数据或者线数据的可视化，可以使用在<a href=\"#geo\">地理坐标系组件</a>上的<a href=\"#series-scatter\">散点图</a>和<a href=\"#series-lines\">线图</a>。</p>\n",
  "series-parallel": "<p>平行坐标系的系列。</p>\n<p><br></p>\n<hr>\n<p><strong>平行坐标系介绍</strong></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Parallel_coordinates\" target=\"_blank\">平行坐标系（Parallel Coordinates）</a> 是一种常用的可视化高维数据的图表。</p>\n<p>例如 <a href=\"#series-parallel.data\">series-parallel.data</a> 中有如下数据：</p>\n<pre><code class=\"lang-javascript\">[\n    [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n    [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n    [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n    [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n    { // 数据项也可以是 Object，从而里面能含有对线条的特殊设置。\n        value: [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;]\n        lineStyle: {...},\n    }\n    ...\n]\n</code></pre>\n<p>数据中，每一行是一个『数据项』，每一列属于一个『维度』。（例如上面数据每一列的含义分别是：『日期』,『AQI指数』, 『PM2.5』, 『PM10』, 『一氧化碳值』, 『二氧化氮值』, 『二氧化硫值』）。</p>\n<p>平行坐标系适用于对这种多维数据进行可视化分析。每一个维度（每一列）对应一个坐标轴，每一个『数据项』是一条线，贯穿多个坐标轴。在坐标轴上，可以进行数据选取等操作。如下：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/parallel-all&edit=1&reset=1\" width=\"600\" height=\"400\" ></iframe>\n\n\n<p><br></p>\n<hr>\n<p><strong>配置方式概要</strong></p>\n<p>『平行坐标系』的 <code class=\"codespan\">option</code> 基本配置如下例：</p>\n<pre><code class=\"lang-javascript\">option = {\n    parallelAxis: [                     // 这是一个个『坐标轴』的定义\n        {dim: 0, name: schema[0].text}, // 每个『坐标轴』有个 &#39;dim&#39; 属性，表示坐标轴的维度号。\n        {dim: 1, name: schema[1].text},\n        {dim: 2, name: schema[2].text},\n        {dim: 3, name: schema[3].text},\n        {dim: 4, name: schema[4].text},\n        {dim: 5, name: schema[5].text},\n        {dim: 6, name: schema[6].text},\n        {dim: 7, name: schema[7].text,\n            type: &#39;category&#39;,           // 坐标轴也可以支持类别型数据\n            data: [&#39;优&#39;, &#39;良&#39;, &#39;轻度污染&#39;, &#39;中度污染&#39;, &#39;重度污染&#39;, &#39;严重污染&#39;]\n        }\n    ],\n    parallel: {                         // 这是『坐标系』的定义\n        left: &#39;5%&#39;,                     // 平行坐标系的位置设置\n        right: &#39;13%&#39;,\n        bottom: &#39;10%&#39;,\n        top: &#39;20%&#39;,\n        parallelAxisDefault: {          // 『坐标轴』的公有属性可以配置在这里避免重复书写\n            type: &#39;value&#39;,\n            nameLocation: &#39;end&#39;,\n            nameGap: 20\n        }\n    },\n    series: [                           // 这里三个系列共用一个平行坐标系\n        {\n            name: &#39;北京&#39;,\n            type: &#39;parallel&#39;,           // 这个系列类型是 &#39;parallel&#39;\n            data: [\n                [1,  55,  9,   56,  0.46,  18,  6,  &#39;良&#39;],\n                [2,  25,  11,  21,  0.65,  34,  9,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;上海&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [3,  56,  7,   63,  0.3,   14,  5,  &#39;良&#39;],\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                ...\n            ]\n        },\n        {\n            name: &#39;广州&#39;,\n            type: &#39;parallel&#39;,\n            data: [\n                [4,  33,  7,   29,  0.33,  16,  6,  &#39;优&#39;],\n                [5,  42,  24,  44,  0.76,  40,  16, &#39;优&#39;],\n                ...\n            ]\n        }\n    ]\n};\n</code></pre>\n<p>需要涉及到三个组件：<a href=\"#parallel\">parallel</a>、<a href=\"#parallelAxis\">parallelAxis</a>、<a href=\"#series-parallel\">series-parallel</a></p>\n<ul>\n<li><p><a href=\"#parallel\">parallel</a></p>\n<p>  这个配置项是平行坐标系的『坐标系』本身。一个系列（<code class=\"codespan\">series</code>）或多个系列（如上图中的『北京』、『上海』、『广州』分别各是一个系列）可以共用这个『坐标系』。</p>\n<p>  和其他坐标系一样，坐标系也可以创建多个。</p>\n<p>  位置设置，也是放在这里进行。</p>\n</li>\n<li><p><a href=\"#parallelAxis\">parallelAxis</a></p>\n<p>  这个是『坐标系』中的坐标轴的配置。自然，需要有多个坐标轴。</p>\n<p>  其中有 <a href=\"#parallelAxis.parallelIndex\">parallelAxis.parallelIndex</a> 属性，指定这个『坐标轴』在哪个『坐标系』中。默认使用第一个『坐标系』。</p>\n</li>\n<li><p><a href=\"#series-parallel\">series-parallel</a></p>\n<p>  这个是『系列』的定义。系列被画到『坐标系』上。</p>\n<p>  其中有 <a href=\"#series-parallel.parallelIndex\">series-parallel.parallelIndex</a> 属性，指定使用哪个『坐标系』。默认使用第一个『坐标系』。</p>\n</li>\n</ul>\n<p><br></p>\n<hr>\n<p><strong>配置注意和最佳实践</strong></p>\n<p>配置多个 <a href=\"#parallelAxis\">parallelAxis</a> 时，有些值一样的属性，如果书写多遍则比较繁琐，那么可以放置在 <a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里。在坐标轴初始化前，<a href=\"#parallel.parallelAxisDefault\">parallel.parallelAxisDefault</a> 里的配置项，会分别融合进 <a href=\"#parallelAxis\">parallelAxis</a>，形成最终的坐标轴的配置。</p>\n<p><strong>如果数据量很大并且发生卡顿</strong></p>\n<p>建议把 <a href=\"#series-parallel.lineStyle.width\">series-parallel.lineStyle.width</a> 设为 <code class=\"codespan\">0.5</code>（或更小），\n可能显著改善性能。</p>\n<p><br></p>\n<hr>\n<p><strong>高维数据的显示</strong></p>\n<p>维度比较多时，比如有 50+ 的维度，那么就会有 50+ 个轴。那么可能会页面显示不下。</p>\n<p>可以通过 <a href=\"#parallel.axisExpandable\">parallel.axisExpandable</a> 来改善显示效果。</p>\n",
  "series-lines": "<p><strong>线图</strong></p>\n<p>用于带有起点和终点信息的线数据的绘制，主要用于地图上的航线，路线的可视化。</p>\n<p>ECharts 2.x 里会用地图上的 <code class=\"codespan\">markLine</code> 去绘制迁徙效果，在 ECharts 3 里建议使用单独的 <code class=\"codespan\">lines</code> 类型图表。</p>\n",
  "series-graph": "<p><strong>关系图</strong></p>\n<p>用于展现节点以及节点之间的关系数据。</p>\n<p><strong>注意：</strong> ECharts 2.x 中 <code class=\"codespan\">force</code> 类型的图表不再在 ECharts 3 中提供支持，转为统一使用 <code class=\"codespan\">graph</code> 去展现关系数据。如果要使用力引导布局，可以将 <a href=\"#series-graph.layout\">layout</a> 配置项设为<code class=\"codespan\">&#39;force&#39;</code>。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=graph&reset=1&edit=1\" width=\"600\" height=\"400\" ></iframe>\n\n",
  "series-sankey": "<p><strong> 桑基图 </strong></p>\n<p>是一种特殊的流图（可以看作是有向无环图）。 它主要用来表示原材料、能量等如何从最初形式经过中间过程的加工或转化达到最终状态。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=sankey-energy&edit=1&reset=1\" width=\"700\" height=\"580\" ></iframe>\n\n\n<p><br>\n<strong>可视编码：</strong></p>\n<p>桑基图将原数据中的每个<code class=\"codespan\">node</code>编码成一个小矩形，不同的节点尽量用不同的颜色展示，小矩形旁边的<code class=\"codespan\">label</code>编码的是节点的名称。</p>\n<p>此外，图中每两个小矩形之间的边编码的是原数据中的<code class=\"codespan\">link</code>，边的粗细编码的是<code class=\"codespan\">link</code>中的<code class=\"codespan\">value</code>。</p>\n<p><br>\n<strong>排序：</strong>\n如果想指定结果的纵向顺序，那么可以把 <a href=\"#series-sankey.layoutIterations\">layoutIterations</a> 设为 <code class=\"codespan\">0</code>，此时纵向的顺序依照数据在 <a href=\"#series-sankey.links\">links</a> 中出现的顺序。</p>\n",
  "series-funnel": "<p><strong>漏斗图</strong></p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=funnel&reset=1&edit=1\" width=\"600\" height=\"400\" ></iframe>\n\n",
  "series-gauge": "<p><strong>仪表盘</strong></p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=gauge-car\" width=\"600\" height=\"500\" ></iframe>\n\n",
  "series-pictorialBar": "<p><strong>象形柱图</strong></p>\n<p>象形柱图是可以设置各种具象图形元素（如图片、<a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" target=\"_blank\">SVG PathData</a> 等）的柱状图。往往用在信息图中。用于有至少一个类目轴或时间轴的<a href=\"#grid\">直角坐标系</a>上。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=pictorialBar-hill&reset=1&edit=1\" width=\"800\" height=\"400\" ></iframe>\n\n\n\n<p><strong>布局</strong></p>\n<p>象形柱图可以被想象为：它首先是个柱状图，但是柱状图的柱子并不显示。这些柱子我们称为『基准柱（reference bar）』，根据基准柱来定位和显示各种象形图形（包括图片）。</p>\n<p>每个象形图形根据基准柱的定位，是通过 <a href=\"#series-pictorialBar.symbolPosition\">symbolPosition</a>、<a href=\"#series-pictorialBar.symbolOffset\">symbolOffset</a> 来调整其于基准柱的相对位置。</p>\n<p>参见例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/pictorialBar-position&reset=1&edit=1\" width=\"800\" height=\"600\" ></iframe>\n\n\n<p>可以使用 <a href=\"#series-pictorialBar.symbolSize\">symbolSize</a> 调整大小，从而形成各种视图效果。</p>\n<p>参见例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/pictorialBar-symbolSize&reset=1&edit=1\" width=\"800\" height=\"600\" ></iframe>\n\n\n\n<p><strong>象形图形类型</strong></p>\n<p>每个图形可以配置成『单独』和『重复』两种类型，即通过 <a href=\"#series-pictorialBar.symbolRepeat\">symbolRepeat</a> 来设置。</p>\n<ul>\n<li>设置为 <code class=\"codespan\">false</code>（默认），则一个图形来代表一个数据项。</li>\n<li>设置为 <code class=\"codespan\">true</code>，则一组重复的图形来代表一个数据项。</li>\n</ul>\n<p>参见例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/pictorialBar-repeat&reset=1&edit=1\" width=\"800\" height=\"400\" ></iframe>\n\n\n<p>每个象形图形可以是基本图形（如 <code class=\"codespan\">&#39;circle&#39;</code>, <code class=\"codespan\">&#39;rect&#39;</code>, ...）、<a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" target=\"_blank\">SVG PathData</a>、图片，参见：<a href=\"#series-pictorialBar.symbolType\">symbolType</a>。</p>\n<p>参见例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/pictorialBar-graphicType&reset=1&edit=1\" width=\"800\" height=\"400\" ></iframe>\n\n\n<p>可以使用 <a href=\"#series-pictorialBar.symbolClip\">symbolClip</a> 对图形进行剪裁。</p>\n<p>参见例子：</p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=doc-example/pictorialBar-clip&reset=1&edit=1\" width=\"800\" height=\"600\" ></iframe>\n\n\n",
  "series-themeRiver": "<p><strong> 主题河流 </strong></p>\n<p>是一种特殊的流图, 它主要用来表示事件或主题等在一段时间内的变化。</p>\n<p><strong>示例：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=themeRiver-lastfm&edit=1&reset=1\" width=\"700\" height=\"580\" ></iframe>\n\n\n\n<p><br>\n<strong>可视编码：</strong></p>\n<p>主题河流中不同颜色的条带状河流分支编码了不同的事件或主题，河流分支的宽度编码了原数据集中的value值。</p>\n<p>此外，原数据集中的时间属性，映射到单个时间轴上。</p>\n",
  "series-custom": "<p><strong>自定义系列</strong></p>\n<p>自定义系列可以自定义系列中的图形元素渲染。从而能扩展出不同的图表。</p>\n<p>同时，echarts 会统一管理图形的创建删除、动画、与其他组件（如 <a href=\"#dataZoom\">dataZoom</a>、<a href=\"#visualMap\">visualMap</a>）的联动，使开发者不必纠结这些细节。</p>\n<p><strong>例如，下面的例子使用 custom series 扩展出了 x-range 图：</strong></p>\n<iframe data-src=\"https://www.echartsjs.com/examples/zh/view.html?c=custom-profile&reset=1&edit=1\" width=\"800\" height=\"500\" ></iframe>\n\n\n<p><strong>更多的例子参见：<a href=\"http://echarts.baidu.com/examples.html#chart-type-custom\" target=\"_blank\">custom examples</a></strong></p>\n<p><strong><a href=\"http://echarts.baidu.com/tutorial.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97\" target=\"_blank\">这里是个教程</a></strong></p>\n<p><br>\n<strong>开发者自定义渲染逻辑（renderItem 函数）</strong></p>\n<p>custom 系列需要开发者自己提供图形渲染的逻辑。这个渲染逻辑一般命名为 <a href=\"#series-custom.renderItem\">renderItem</a>。例如：</p>\n<pre><code class=\"lang-js\">var option = {\n    ...,\n    series: [{\n        type: &#39;custom&#39;,\n        renderItem: function (params, api) {\n            var categoryIndex = api.value(0);\n            var start = api.coord([api.value(1), categoryIndex]);\n            var end = api.coord([api.value(2), categoryIndex]);\n            var height = api.size([0, 1])[1] * 0.6;\n\n            var rectShape = echarts.graphic.clipRectByRect({\n                x: start[0],\n                y: start[1] - height / 2,\n                width: end[0] - start[0],\n                height: height\n            }, {\n                x: params.coordSys.x,\n                y: params.coordSys.y,\n                width: params.coordSys.width,\n                height: params.coordSys.height\n            });\n\n            return rectShape &amp;&amp; {\n                type: &#39;rect&#39;,\n                shape: rectShape,\n                style: api.style()\n            };\n        },\n        data: data\n    }]\n}\n</code></pre>\n<p>对于 <code class=\"codespan\">data</code> 中的每个数据项（为方便描述，这里称为 <code class=\"codespan\">dataItem</code>)，会调用此 <a href=\"#series-custom.renderItem\">renderItem</a> 函数。</p>\n<p><a href=\"#series-custom.renderItem\">renderItem</a> 函数提供了两个参数：</p>\n<ul>\n<li><a href=\"#series-custom.renderItem.arguments.params\">params</a>：包含了当前数据信息和坐标系的信息。</li>\n<li><a href=\"#series-custom.renderItem.arguments.api\">api</a>：是一些开发者可调用的方法集合。</li>\n</ul>\n<p><a href=\"#series-custom.renderItem\">renderItem</a> 函数须返回根据此 <code class=\"codespan\">dataItem</code> 绘制出的图形元素的定义信息，参见 <a href=\"#series-custom.renderItem.return\">renderItem.return</a>。</p>\n<p>一般来说，<a href=\"#series-custom.renderItem\">renderItem</a> 函数的主要逻辑，是将 <code class=\"codespan\">dataItem</code> 里的值映射到坐标系上的图形元素。这一般需要用到 <a href=\"#series-custom.renderItem.arguments.api\">renderItem.arguments.api</a> 中的两个函数：</p>\n<ul>\n<li><a href=\"#series-custom.renderItem.arguments.api.value\">api.value(...)</a>，意思是取出 <code class=\"codespan\">dataItem</code> 中的数值。例如 <code class=\"codespan\">api.value(0)</code> 表示取出当前 <code class=\"codespan\">dataItem</code> 中第一个维度的数值。</li>\n<li><a href=\"#series-custom.renderItem.arguments.api.coord\">api.coord(...)</a>，意思是进行坐标转换计算。例如 <code class=\"codespan\">var point = api.coord([api.value(0), api.value(1)])</code> 表示 <code class=\"codespan\">dataItem</code> 中的数值转换成坐标系上的点。</li>\n</ul>\n<p>有时候还需要用到 <a href=\"#series-custom.renderItem.arguments.api.size\">api.size(...)</a> 函数，表示得到坐标系上一段数值范围对应的长度。</p>\n<p>返回值中样式的设置可以使用 <a href=\"#series-custom.renderItem.arguments.api.style\">api.style(...)</a> 函数，他能得到 <a href=\"#series-custom.itemStyle\">series.itemStyle</a> 中定义的样式信息，以及视觉映射的样式信息。也可以用这种方式覆盖这些样式信息：<code class=\"codespan\">api.style({fill: &#39;green&#39;, stroke: &#39;yellow&#39;})</code>。</p>\n<p><br>\n<strong>维度的映射（encode 和 dimensions 属性）</strong></p>\n<p><code class=\"codespan\">custom</code> 系列往往需要定义 <a href=\"#series-custom.encode\">series.encode</a>，主要用于指明 <code class=\"codespan\">data</code> 的哪些维度映射到哪些数轴上。从而，echarts 能根据这些维度的值的范围，画出合适的数轴刻度。\n同时，encode.tooltip 和 encode.label 也可以被指定，指明默认的 tooltip 和 label 显示什么内容。<a href=\"#series-custom.dimensions\">series.dimensions</a> 也可以被指定，指明显示在 tooltip 中的维度名称，或者维度的类型。</p>\n<p>例如：</p>\n<pre><code class=\"lang-js\">series: {\n    type: &#39;custom&#39;,\n    renderItem: function () {\n        ...\n    },\n    encode: {\n        x: [2, 4, 3],\n        y: 1,\n        label: 0,\n        tooltip: [2, 4, 3]\n    }\n}\n</code></pre>\n<p><br>\n<strong>与 dataZoom 组件的结合</strong></p>\n<p>与 <a href=\"#dataZoom\">dataZoom</a> 结合使用的时候，常常使用会设置 <a href=\"#dataZoom.filterMode\">dataZoom.filterMode</a> 为 &#39;weakFilter&#39;，从而让 <code class=\"codespan\">dataItem</code> 部分超出坐标系边界的时候，不会整体被过滤掉。</p>\n<p><br>\n<strong>关于 <code class=\"codespan\">dataIndex</code> 和 <code class=\"codespan\">dataIndexInside</code> 的区别</strong></p>\n<ul>\n<li><code class=\"codespan\">dataIndex</code> 指的 <code class=\"codespan\">dataItem</code> 在原始数据中的 index。</li>\n<li><code class=\"codespan\">dataIndexInside</code> 指的是 <code class=\"codespan\">dataItem</code> 在当前数据窗口（参见 <a href=\"#dataZoom\">dataZoom</a>）中的 index。</li>\n</ul>\n<p><a href=\"#series-custom.renderItem.arguments.api\">renderItem.arguments.api</a> 中使用的参数都是 <code class=\"codespan\">dataIndexInside</code> 而非 <code class=\"codespan\">dataIndex</code>，因为从 <code class=\"codespan\">dataIndex</code> 转换成 <code class=\"codespan\">dataIndexInside</code> 需要时间开销。</p>\n<p><br>\n<strong>Event listener</strong></p>\n<pre><code class=\"lang-js\">chart.setOption({\n    // ...\n    series: {\n        type: &#39;custom&#39;,\n        renderItem: function () {\n            // ...\n            return {\n                type: &#39;group&#39;,\n                children: [{\n                    type: &#39;circle&#39;\n                    // ...\n                }, {\n                    type: &#39;circle&#39;,\n                    name: &#39;aaa&#39;,\n                    // 用户指定的信息，可以在 event handler 访问到。\n                    info: 12345,\n                    // ...\n                }]\n            };\n        }\n    }\n});\nchart.on(&#39;click&#39;, {element: &#39;aaa&#39;}, function (params) {\n    // 当 name 为 &#39;aaa&#39; 的图形元素被点击时，此回调被触发。\n    console.log(params.info);\n});\n</code></pre>\n",
  "color": "<p>调色盘颜色列表。如果系列没有设置颜色，则会依次循环从该列表中取颜色作为系列颜色。</p>\n<p>默认为：</p>\n<pre><code class=\"lang-js\">[&#39;#c23531&#39;,&#39;#2f4554&#39;, &#39;#61a0a8&#39;, &#39;#d48265&#39;, &#39;#91c7ae&#39;,&#39;#749f83&#39;,  &#39;#ca8622&#39;, &#39;#bda29a&#39;,&#39;#6e7074&#39;, &#39;#546570&#39;, &#39;#c4ccd3&#39;]\n</code></pre>\n",
  "backgroundColor": "<p>背景色，默认无背景。</p>\n<blockquote>\n<p>颜色可以使用 RGB 表示，比如 <code class=\"codespan\">&#39;rgb(128, 128, 128)&#39;</code>，如果想要加上 alpha 通道表示不透明度，可以使用 RGBA，比如 <code class=\"codespan\">&#39;rgba(128, 128, 128, 0.5)&#39;</code>，也可以使用十六进制格式，比如 <code class=\"codespan\">&#39;#ccc&#39;</code>。除了纯色之外颜色也支持渐变色和纹理填充</p>\n<pre><code class=\"lang-js\">// 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置\ncolor: {\n    type: &#39;linear&#39;,\n    x: 0,\n    y: 0,\n    x2: 0,\n    y2: 1,\n    colorStops: [{\n        offset: 0, color: &#39;red&#39; // 0% 处的颜色\n    }, {\n        offset: 1, color: &#39;blue&#39; // 100% 处的颜色\n    }],\n    global: false // 缺省为 false\n}\n// 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变\ncolor: {\n    type: &#39;radial&#39;,\n    x: 0.5,\n    y: 0.5,\n    r: 0.5,\n    colorStops: [{\n        offset: 0, color: &#39;red&#39; // 0% 处的颜色\n    }, {\n        offset: 1, color: &#39;blue&#39; // 100% 处的颜色\n    }],\n    global: false // 缺省为 false\n}\n// 纹理填充\ncolor: {\n    image: imageDom, // 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串\n    repeat: &#39;repeat&#39; // 是否平铺, 可以是 &#39;repeat-x&#39;, &#39;repeat-y&#39;, &#39;no-repeat&#39;\n}\n</code></pre>\n</blockquote>\n",
  "textStyle": "<p>全局的字体样式。</p>\n",
  "animation": "<p>是否开启动画。</p>\n",
  "animationThreshold": "<p>是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画。</p>\n",
  "animationDuration": "<p>初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果：</p>\n<pre><code class=\"lang-js\">animationDuration: function (idx) {\n    // 越往后的数据延迟越大\n    return idx * 100;\n}\n</code></pre>\n",
  "animationEasing": "<p>初始动画的缓动效果。不同的缓动效果可以参考 <a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=line-easing\" target=\"_blank\">缓动示例</a>。</p>\n",
  "animationDelay": "<p>初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果。</p>\n<p>如下示例：</p>\n<pre><code class=\"lang-js\">animationDelay: function (idx) {\n    // 越往后的数据延迟越大\n    return idx * 100;\n}\n</code></pre>\n<p>也可以看<a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=bar-animation-delay\" target=\"_blank\">该示例</a></p>\n",
  "animationDurationUpdate": "<p>数据更新动画的时长。</p>\n<p>支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果：</p>\n<pre><code class=\"lang-js\">animationDurationUpdate: function (idx) {\n    // 越往后的数据延迟越大\n    return idx * 100;\n}\n</code></pre>\n",
  "animationEasingUpdate": "<p>数据更新动画的缓动效果。</p>\n",
  "animationDelayUpdate": "<p>数据更新动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果。</p>\n<p>如下示例：</p>\n<pre><code class=\"lang-js\">animationDelayUpdate: function (idx) {\n    // 越往后的数据延迟越大\n    return idx * 100;\n}\n</code></pre>\n<p>也可以看<a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=bar-animation-delay\" target=\"_blank\">该示例</a></p>\n",
  "blendMode": "<p>图形的混合模式，不同的混合模式见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\" target=\"_blank\">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation</a> 。</p>\n<p>默认为 <code class=\"codespan\">&#39;source-over&#39;</code>。 支持每个系列单独设置。</p>\n<p><code class=\"codespan\">&#39;lighter&#39;</code> 也是比较常见的一种混合模式，该模式下图形数量集中的区域会颜色叠加成高亮度的颜色（白色）。常常能起到突出该区域的效果。见示例 <a href=\"https://www.echartsjs.com/examples/zh/editor.html?c=lines-airline\" target=\"_blank\">全球飞行航线</a></p>\n",
  "hoverLayerThreshold": "<p>图形数量阈值，决定是否开启单独的 hover 层，在整个图表的图形数量大于该阈值时开启单独的 hover 层。</p>\n<p>单独的 hover 层主要是为了在高亮图形的时候不需要重绘整个图表，只需要把高亮的图形放入单独的一个 canvas 层进行绘制，防止在图形数量很多的时候因为高亮重绘所有图形导致卡顿。</p>\n<p>ECharts 2 里是底层强制使用单独的层绘制高亮图形，但是会带来很多问题，比如高亮的图形可能会不正确的遮挡所有其它图形，还有图形有透明度因为高亮和正常图形叠加导致不正确的透明度显示，还有移动端上因为每个图表都要多一个 canvas 带来的额外内存开销。因此 3 里默认不会开启该优化，只有在图形数量特别多，有必要做该优化时才会自动开启。</p>\n",
  "useUTC": "<p>是否使用 UTC 时间。</p>\n<ul>\n<li><code class=\"codespan\">true</code>: 表示 <code class=\"codespan\">axis.type</code> 为 <code class=\"codespan\">&#39;time&#39;</code> 时，依据 UTC 时间确定 tick 位置，并且 <code class=\"codespan\">axisLabel</code> 和 <code class=\"codespan\">tooltip</code> 默认展示的是 UTC 时间。</li>\n<li><code class=\"codespan\">false</code>: 表示 <code class=\"codespan\">axis.type</code> 为 <code class=\"codespan\">&#39;time&#39;</code> 时，依据本地时间确定 tick 位置，并且 <code class=\"codespan\">axisLabel</code> 和 <code class=\"codespan\">tooltip</code> 默认展示的是本地时间。</li>\n</ul>\n<p>默认取值为false，即使用本地时间。因为考虑到：</p>\n<ul>\n<li>很多情况下，需要展示为本地时间（无论服务器存储的是否为 <code class=\"codespan\">UTC</code> 时间）。</li>\n<li>如果 data 中的时间为 &#39;2012-01-02&#39; 这样的没有指定时区的时间表达式，往往意为本地时间。默认情况下，时间被展示时需要和输入一致而非有时差。</li>\n</ul>\n<p>注意，这个参数实际影响的是『展示』，而非用户输入的时间值的解析。\n关于用户输入的时间值（例如 <code class=\"codespan\">1491339540396</code>, <code class=\"codespan\">&#39;2013-01-04&#39;</code> 等）的解析，参见 <a href=\"#series-line.data\">date 中时间相关部分</a>。</p>\n"
}